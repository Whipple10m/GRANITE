!Modified:

! 	12/03/02 GHS
!         	Add a SET_CFD_MASK routine. This will alow for disableing
!               channels in the mult and pst trigger but not in the ADC.
!               Note: A bit SET in the mask disables that channel.
!       13/03/02 GHS
!               Move the CAMAC_DEF module to a seperate file: gr_camac_def.f90
!               Do this so the linking will work.
!       13/03/02 GHS
!               Add a 'slot' argument to GPR10_SET_DISCS. A value of -1 means
!               update all cfd slots. Otherwise only update/set that slot. Do
!               this to spped up the GPR10_SET_MASK routine


   MODULE LP_COMMANDS
        USE GHY                                    ! HYTEC interface 
	IMPLICIT NONE
	SAVE
	integer*2,parameter :: q_ignore=2**14 !Bit 15(out of 1-16): 40000 octal

   CONTAINS
!	Fuctions that build list processor commands:
   INTEGER*2 FUNCTION FNA(F,N,A)
!Hytec List Processor FNA command
	IMPLICIT NONE
	integer :: f,n,a
	integer*4 :: temp
 	integer*2 :: i2tplate
	temp=n*512+a*32+f
	fna=transfer(temp,i2tplate)
   END FUNCTION FNA

   INTEGER*2 FUNCTION JMP(madd)
!Hytec List Processor Uncopnditional Jump command
	IMPLICIT NONE
	integer*4 :: temp
	integer :: madd
 	integer*2 :: i2tplate
	integer,parameter:: jmp_base= 2**15+2**14	!(140000 octal)
	temp=jmp_base+madd		! unconditional jump to MADD
	jmp=transfer(temp,i2tplate)
    END FUNCTION JMP
                
   INTEGER*2 FUNCTION JMPAWT(madd)
!Hytec List Processor Jump and await trigger command
	IMPLICIT NONE
	integer*4 :: temp
	integer :: madd
 	integer*2 :: i2tplate
	integer,parameter:: jmpawt_base= 2**15+2**14+2**13  !(160000 octal)
	temp=jmpawt_base+madd		! unconditional jump to MADD
	jmpawt=transfer(temp,i2tplate)
    END FUNCTION JMPAWT

   INTEGER*2 FUNCTION JMPNOQ(madd)
!Hytec List Processor Jump on no Q command
	IMPLICIT NONE
	integer :: madd
	integer*4 :: temp
 	integer*2 :: i2tplate
	integer,parameter:: jmpnoq_base= 2**15+2**14+2**11  !(144000 octal)
	temp=jmpnoq_base+madd		! unconditional jump to MADD
	jmpnoq=transfer(temp,i2tplate) 
    END FUNCTION JMPNOQ

   INTEGER*2 FUNCTION JMPGT(madd)
!Hytec List Processor Jump on greater then stored value command
	IMPLICIT NONE
	integer :: madd
	integer*4 :: temp
 	integer*2 :: i2tplate
	integer,parameter:: jmpgt_base= 2**15+2**14+2**12  !(150000 octal)
	temp=jmpgt_base+madd		! unconditional jump to MADD
	jmpgt=transfer(temp,i2tplate) 
    END FUNCTION JMPGT

   END MODULE LP_COMMANDS

MODULE GPR10                                    

!-------------------------------------------------------------------------------
!
!       10 m telescope CAMAC readout 
!
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!       This is the "producer thread" for the 10m upgraded 331 pixel data
!       acquisition.
!       It is derived from the 10m 151 pixel version of the PRODUCER TASK with
!       major changes to use it in a THREAD envrionment. It is POSIX compliant
!       and the frame/event structure has been replace with a simpler
!       event structure.
!       At present will have only two types of events:
!       1: Normal data event:This type of event is caused by a normal event
!               trigger.Readout are ADC's for all pixels,clocks,encoders,Trigger
!               Pattern data, etc.
!       2: Pedestal event:This event comes at a set intervel(on the second
!               mark for example) and records the same data as the normal events
!               except that since there is no real event present the ADC's have
!               pedestal information and no Trigger pattern data is read out.
!               The singles scalers are also read out in this event.

!       For the actual data acquisition the Hytec Ethernet Crate Controllers
!       (ECC) and List Processors (LP) are used to do all the camac stuff.
!       To optimize the data transfer speed into the computer, it is desirable
!	to read large buffers (usually with >4000 words each) of events from 
!	the LP's.  This is accomplished by waiting for a time intervel
!	calculated from the measured event rates and the event sizes in the
!	LPs. If the event rate is very low the maximum time we wait is 1 sec. 
!	If the event rate is very high(150 Hz max is probably our limit) we
!	wait a minimum of .1 sec. When the time intervel is up, whatever is in
!	the  LP buffers is readout. Then,using an event number tagging system,
!	events are reformated and assembled into the GDF(granite data format).
!       These are then released to a "writer thread"(provided by Joachim Rose).
!       Synchronization with the hardware is accomplished via
!       pulses generated by  custum built CAMAC output and input register
!       moduals(SOB).
!
!	For a nitrogen run (NITROGEN_RUN=.TRUE.)where the trigger rate is 
!	extreamly high( >1Khz) the same procedure is used except that we
!       wait a set time	(NITROGEN_TIME, nominally .1 sec). At the end
!	of the wait before reading out whatever data has been obtained 
!	this program tells the LP's to close the event gate. The data is then 
!	read out as normal and then the event gate is reopened. This prevents 
!	the nitrogen events which are coming in at over 1 khz from overwiritng
!	previous events in the LP memory before the computer can read the 
!	events out.
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!	Written by:
!		Glenn Sembroski
!		Physics Dept.
!		Purdue Univ.
!		W.Lafayette, In 47907
!  		31-Jul-1997
!	Modified:
!	17/9/97 GHS
!		The new SOB's that Chcuk made (and tested he said) have the
!		old problem of output channel 0 get a spurious short pulse
!		when other channels are accessed. So to avioid problems we
!		won't use output channel 0 for anything.
!       30/09/97 MAC
!               Reenable CFDs 2-8
!	01/10/97 GHS
!		A a /SET THRESHOLD command( gpr10_set_cfd_threshold)
!	11/2/99 GHS
!		Modify Nitrogen Run code. Add capability to turn N2 on and
!		off through sob1-a2-out and sob-a3-out(respectivly). Do this
!		through new routines: GPR10_N2_ON and GPR10_N2_OFF.
!		In GPR10_START modifiy N2 code to do the following:
!			1: Before n2 is turned on generate 1 pedestal
!			   event through sob1-a4-out (GPR10_PEDESTAL_GEN).
!			   whos output is 'or'ed to the 1pps trigger to 
!			   generate pedestal events.
!			2: Turn on N2. Wait .1 sec. Open event gate.
!			   Wait .1 sec. Close event gate .Turn off N2
!			3: Repeat from 1.
!		In general before the start of all runs insure N2 is off!
!	12/2/99 GHS
!		Fix index for bad tag searches in pst's:GPR10_CHECK_LP4
!	15/5/99 GHS
!		Add code to the gpr10_action routine to check if we have 
!		enough disk space for the next run.
!	16/5/99 GHS
!		Put in a check to see if the livetime scaler resets. if it
!		does put out a warning message only. We may disable this at
!		some time in the future if it gets annoying.  Also don't
!		do a  C Z in crate 4 only when were restarting the run. This
!		is probably how we were resetting the scaler.
!	19/5/99 GHS
!		Add a new subroutine GPR10_CRATE5_RESTART That resets and
!		restarts crate 5
!		(the scaler crate) when it gets hung without interupting
!		the normal data acquisition. It is called in GPR10_MERGE_DATA
!		Which is were crate 5 health is checked. This new routine
!		is basically a striped down version of GPR10_INIT.
! 	12/03/02 GHS
!         	Add a SET_CFD_MASK routine. This will alow for disableing
!               channels in the mult and pst trigger but not in the ADC.
!      	13/03/02 GHS
!		Add a GPR10_SHOW_CFD_DISABLED routine.
!       31/08/02 GHS
!               Set gon_ctrl%pr10_active to mimic gpr10_ctrl%run_status
!               Used in GR_ONLINE to prevent changing rn number during a run.
 
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------

        USE GON  
        USE GHY                                    ! HYTEC interface 
        USE GBM                  
        USE GTR
        USE GDF                  
        USE GOS  
			
	IMPLICIT NONE 

        PRIVATE 
        
!-------------------------------------------------------------------------------
!       control flags to communicate with other threads
!-------------------------------------------------------------------------------
        TYPE, PUBLIC :: GPR10_CTRL_T
          LOGICAL :: EXIT                   ! request to exit nicely
          LOGICAL :: QUIT                   ! External request for a nasty 
					    ! quick exit 
	  LOGICAL :: RUN_STATUS		    ! RUN IN PROGRESS FLAG.
	  logical :: nitrogen_run	    ! True if this is a Nitrogen run
					    ! and the computer needs to stop
					    ! and start data acq to prevent lP
					    ! wrap arounds.
          real*8  :: max_gap		    !Maximum time to allow
						!for no event before a TIME GAP
						!is declared:GPR10_READ_CAMAC.
						!(in MJD)	
                                        !We can set it to 2 sec since we should
					!get pedestal events every second.
	  logical :: override		!Flag that lets us override too little
					!disk space for a run
	  logical :: enough_disk	!Flag for varius rouitne that we have
					!enough disk space to start a run.
	  integer :: typical_run_size    !minimum acceptable free disk space in
					! blocks before a run.
	  integer :: typical_n2_run_size !minimum acceptable free disk space in
					! blocks before a nitrogen run.
	END TYPE GPR10_CTRL_T 

        TYPE(GPR10_CTRL_T), PUBLIC :: GPR10_CTRL = &
	& gpr10_ctrl_t(.false.,.false.,.false.,.false.,2./(24.*3600.),&
	& .false., &		!No disk space override
	& .true., &		!assum we have enough unless forced to say not.
	& 400000, &		!Max size in blocks of normal 100 hz run
	& 20000)                !Max size in blocks of N2 run


!-------------------------------------------------------------------------------
!       status information other threads may need to know about 
!-------------------------------------------------------------------------------
        TYPE, PUBLIC :: GPR10_STATUS_T
          INTEGER :: EVENT                  ! events read so far 
          REAL    :: RATE                   ! event rate [Hz]
        END TYPE GPR10_STATUS_T 

        TYPE(GPR10_STATUS_T), PUBLIC :: GPR10_STATUS    

!-------------------------------------------------------------------------------
!       subroutines that are called by other threads 
!-------------------------------------------------------------------------------
        PUBLIC :: GPR10_START                  ! entry for threads 
	PUBLIC :: GPR10_SET_STATE              ! called from KUIP 
	PUBLIC :: GPR10_ACTION                 ! called from KUIP 
	PUBLIC :: GPR10_SET_CFD_THRESHOLD      ! called from KUIP 
        PUBLIC :: GPR10_SHOW_CFD_THRESHOLD     ! called from KUIP 
        PUBLIC :: GPR10_SYNCH		       ! called from KUIP 
	PUBLIC :: GPR10_SET_CFD_MASK           ! called from KUIP 
	PUBLIC :: GPR10_SHOW_CFD_DISABLED      ! called from KUIP 


!-------------------------------------------------------------------------------
!       input file 
!-------------------------------------------------------------------------------
        CHARACTER(132) FILE 
        LOGICAL verbose
       

!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  CONTAINS
!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

    SUBROUTINE GPR10_ACTION 

!-------------------------------------------------------------------------------
!       change module state 
!-------------------------------------------------------------------------------
!	Modified:
!	15/5/99 GHS
!		Add code to check if we have enough disk space for the next run.
!       31/08/02 GHS
!               Check upon kill or run exit command if run is in progress. If
!               so, give a message and return.



        IMPLICIT NONE 

        CHARACTER(len=32) :: CMD        ! command invoked 
        CHARACTER(len=80) :: MSG        ! error message 
        INTEGER  ::          NPAR       ! number of command parameters 
        INTEGER  ::          IERR       ! return code         
	integer  ::          i
        INTEGER              LEN 
        CHARACTER(32)        THREAD
        CHARACTER(*), PARAMETER :: SRN = "GPR10_ACTION" 
	character(len=1)           :: BELL

	data BELL /7/         

      CALL KUPATL(CMD,NPAR) 
      CALL CLTOU(CMD)                      ! convert to upper case 
!-------------------------------------------------------------------------------
!     start a new thread for a normal run
!-------------------------------------------------------------------------------
      IF (CMD.EQ.'START') THEN                             
	if(gpr10_ctrl%run_status)then
	        IERR = GOS_ERROR(SRN,"Run is already in progress",1)
		print *,BELL
		return
	endif
				!Check available disk space on dir$data.
	if(.not.gpr10_ctrl%enough_disk)then
				!Not enough space
	  IERR = GOS_ERROR(SRN,"Start of Producer thread aborted by &
	  & lack of disk space.",1)
		print *,BELL
		return
	endif

	gpr10_ctrl%nitrogen_run=.false.
	CALL GOS_CREATE_THREAD(& 
          GOS_THREAD%PRODUCER10,& 
          GPR10_START,&
          IERR)
!-------------------------------------------------------------------------------
!     start a new thread for a Nitrogen run
!-------------------------------------------------------------------------------
      elseif (CMD.EQ.'START_N2') THEN                             
	if(gpr10_ctrl%run_status)then
	        IERR = GOS_ERROR(SRN,"Run is already in progress",1)
		print *,BELL
		return
	endif

	if(.not.gpr10_ctrl%enough_disk)then
				!Not enough space
	  IERR = GOS_ERROR(SRN,"Start of Producer thread aborted by &
	  & lack of disk space.",1)
		print *,BELL
		return
	endif

	gpr10_ctrl%nitrogen_run=.true.
        CALL GOS_CREATE_THREAD(& 
          GOS_THREAD%PRODUCER10,& 
          GPR10_START,&
          IERR)
!-------------------------------------------------------------------------------
!     stop  a thread the nice way  
!-------------------------------------------------------------------------------
      ELSE IF (CMD.EQ.'STOP') THEN
 	if(.not.gpr10_ctrl%run_status)then
	        IERR = GOS_ERROR(SRN,"No run in progress",1)
		print *,BELL
		return
	endif
 	GPR10_CTRL%EXIT = .TRUE.
!-------------------------------------------------------------------------------
!     stop a thread, regardless of 
!-------------------------------------------------------------------------------
      ELSE IF (CMD.EQ.'KILL') THEN
 	if(.not.gpr10_ctrl%run_status)then
	        IERR = GOS_ERROR(SRN,"No run in progress",1)
		print *,BELL
		return
	endif
        GPR10_CTRL%QUIT = .TRUE.
!-------------------------------------------------------------------------------
!
!-------------------------------------------------------------------------------
      ELSE
        IERR = GOS_ERROR(SRN,'Unknown command '//CMD,1)
      ENDIF

    END SUBROUTINE GPR10_ACTION 
!*****************************************************************************

    SUBROUTINE GPR10_FREESPACE 

!-------------------------------------------------------------------------------
!       check disk space available on dir$data.
!	ierr=1 means abort run
!-------------------------------------------------------------------------------
        IMPLICIT NONE 

        CHARACTER(len=80) :: MSG        ! error message 
        CHARACTER(*), PARAMETER :: SRN = "GPR10_freespace" 
        INTEGER :: IERR       		! return code         
	integer :: disk_space,run_size
	integer :: lib$getdvi
	include '($dvidef)'
        INTEGER  ::          NPAR       ! number of command parameters 
	integer :: clen
        CHARACTER(len=8) :: type      ! Run type

!Note: only one 'return' in this routine and thats on purpose(to insure override
!gets cleared)!


      CALL KUGETC(type,CLEN)                ! get run type 
      CALL CLTOU(type)                      ! convert to upper case 

      IF (type.EQ.'START') THEN                             
		run_size=gpr10_ctrl%typical_run_size
      elseif(type.EQ.'START_N2') THEN                             
		run_size=gpr10_ctrl%typical_n2_run_size
      ELSE
        IERR = GOS_ERROR(SRN,'Unknown run type'//TYPE,1)
	return
      ENDIF

!Get available disk space on dir$data
!-------------------------------------------------------------------------------
!     get access to VMS system routines 
!-------------------------------------------------------------------------------
	CALL GOS_LOCK(GOS_MUTEX_VMS,IERR) 

	ierr=lib$getdvi(DVI$_FREEBLOCKS,,"dir$data",disk_space)

!-------------------------------------------------------------------------------
!     release lock 
!-------------------------------------------------------------------------------
	CALL GOS_UNLOCK(GOS_MUTEX_VMS,IERR) 

					!see if we should abort run.
	gpr10_ctrl%enough_disk=.true.	!Assume we don't

	if(disk_space<run_size)then
	        IERR = GOS_ERROR(SRN,"Not enough free blocks on DIR$DATA for&
		& a new run.",1)
		write(msg,'("Minimum required disk space for run",i10, &
			& " blocks.")')run_size
	        IERR = GOS_ERROR(SRN,MSG,1)
		write(msg,'("Presently available space is",i10, &
		" blocks.")')disk_space
	        IERR = GOS_ERROR(SRN,MSG,1)
					  !check if override of abort is set
		if(gpr10_ctrl%override)then
		        IERR = GOS_ERROR(SRN,"OVERRIDE of minimum in effect. &
		& Run will continue.",1)
		else
		        IERR = GOS_ERROR(SRN,"Use OVERRIDE command to force &
				& run to start.",1)
			gpr10_ctrl%enough_disk=.false.
		endif
	elseif(disk_space<2*run_size)then
	        IERR = GOS_ERROR(SRN,"WARNING: Free disk space &
				& approacing minimum.",1)
		write(msg,'("Minimum required disk space for run",i10, &
			& " blocks.")')run_size
	        IERR = GOS_ERROR(SRN,MSG,1)
		write(msg,'("Presently available space is",i10, &
		" blocks.")')disk_space
	        IERR = GOS_ERROR(SRN,MSG,1)
 	endif

	gpr10_ctrl%override=.false.		!Clear override.
	return
    END SUBROUTINE GPR10_FREESPACE
!****************************************************************************

    SUBROUTINE GPR10_START
!-------------------------------------------------------------------------------
!       first routine that is called when the producer thread is created 
!-------------------------------------------------------------------------------
!Modified:
!	11/2/99 GHS
!		Modify Nitrogen Run code. Add capability to turn N2 on and
!		off through sob1-a2-out and sob-a3-out(respectivly). Do this
!		through new routines: GPR10_N2_ON and GPR10_N2_OFF.
!		In GPR10_START modifiy N2 code to do the following:
!			1: Before n2 is turned on generate 1 pedestal
!			   event through sob1-a4-out (GPR10_PEDESTAL_GEN).
!			   whos output is 'or'ed to the 1pps trigger to 
!			   generate pedestal events.
!			2: Turn on N2. Wait .1 sec. Open event gate.
!			   Wait .1 sec. Close event gate .Turn off N2
!			3: Repeat from 1.
!		In general before the start of all runs insure N2 is off!
	use camac_def

        IMPLICIT NONE 
	real*8 :: utc
        integer :: jerr         ! INTEGER return code 
	logical :: ierr		!Returned value which indicates need to abort
				!thread imeadiately(on .TRUE. value)
				!Error message printout assumed to occur within
				!the called routine.
        logical :: got_data
	character(len=*),PARAMETER :: SRN="GPR10_START"
	character(len=132)         :: MSG
	character(len=1)           :: BELL

	data BELL /7/         

         verbose = .false. !let's not bother the observer with too many error messages!
!	 verbose = .true.

!----  startup phase 
	GPR10_CTRL%QUIT = .FALSE.                   ! reset flag 
	GPR10_CTRL%EXIT = .FALSE.                   ! reset flag 
	GPR10_CTRL%RUN_STATUS=.TRUE.		    !RUN IS IN PROGRESS.
	gon_ctrl%pr10_active=gpr10_ctrl%run_status

	CALL GPR10_INIT(ierr)                         ! get CAMAC ready 
						!Compile LP programs and load 
						!them into the LP's
	if(ierr)THEN
		GPR10_CTRL%RUN_STATUS=.FALSE.     !RUN IS NOT IN PROGRESS.
		gon_ctrl%pr10_active=gpr10_ctrl%run_status
!HJR 	  	call ccfini(branch)		  !Disconnect from camac
	  	call ccfini			  !Disconnect from camac
		return				  !No gbm flushing needed
	endif

!Wait for start of run time.
	CALL GOS_UTC(UTC)                           ! get UTC time 

	DO 
	    if(UTC < GDF_RUN%UTC_START)then         ! time to open gate?  
	        CALL GPR10_WAIT(0.1)                        !   no, wait a bit 
	        IF (GPR10_CTRL%QUIT) then               !   exit requested?
			GPR10_CTRL%RUN_STATUS=.FALSE.     !RUN NOT IN PROGRESS.
			gon_ctrl%pr10_active=gpr10_ctrl%run_status
!HJR		  	call ccfini(branch)	  	  !Disconnect from camac
		  	call ccfini		  	  !Disconnect from camac
			return			    !No gbm flushing needed
		endif
	        IF (GPR10_CTRL%EXIT) then               !   exit requested?
			GPR10_CTRL%RUN_STATUS=.FALSE.     !RUN NOT IN PROGRESS.
			gon_ctrl%pr10_active=gpr10_ctrl%run_status
!HJR		  	call ccfini(branch)	  	  !Disconnect from camac
		  	call ccfini		  	  !Disconnect from camac
			return			    !No gbm flushing needed
		endif
	        CALL GOS_UTC(UTC)                         !   update UTC time 
            else
		call gpr10_n2_off	    !Make sure n2 pulser is not on
 		CALL GPR10_OPEN_GATE        ! open gate. THis starts the Run
 		exit
	    endif
	ENDDO                                       !   keep waiting  

 
!This is the main data acquisition loop.
!---- read and process LP data
	gpr10_status%rate=10.0			    !assume low rate to start


	DO 
            CALL GOS_UTC(UTC)                       !   update UTC time 

	    if(UTC < GDF_RUN%UTC_END)then        ! time to close gate?

				!Set time to wait
		if(gpr10_ctrl%nitrogen_run)then    !If we have a nitrogen run
			time_to_wait=nitrogen_time !wait for a predetermined
					   	   !time. not too long!
					!Generate a small number of pedestal
					!events. Like 1.
			call gpr10_pedestal_gen
						!I don't think we need any
						!delay here. Camac command is 
						!slow enough.
!May be needed		CALL GPR10_REQUEST_PAUSE    !Request close of event
!This may wait 1 sec.				    !gate.


			call gpr10_n2_on	!Start N2 pulsar.


!May be needed 		call gpr10_wait(.1)	!Wait for a N2 to come up to
						!speed
!May be needed		CALL GPR10_OPEN_GATE        ! open gate. THis starts the Run
		else
			!Use reuested lp1 buffer size, the guessed upon data 
			!rate and the length of the lp1 events to guess at
			!how long to wait.
!HJR 		 	time_to_wait=MIN(lp1_min_buffer_size/ &
!HJR				     & (gpr10_status%rate*lp3%event_length),1.0)
!HJR							!Minimum wait time.
!HJR 		        if(time_to_wait<0.01)time_to_wait=0.01
 		 	time_to_wait=  lp1_min_buffer_size/ &
				     & (gpr10_status%rate*lp3%event_length)
 		        time_to_wait = MIN(time_to_wait,3.0)	!Sets max 
 		        time_to_wait = MAX(time_to_wait,2.0)    !sets min
		endif
              
               		call gpr10_wait(time_to_wait)!Wait for a predicted time 
			call gpr10_n2_off	!Turn off N2 pulsar(even if its
						!already off, dosen't hurt).              
		IF (GPR10_CTRL%EXIT) THEN  !if exit, finish off run nicely
                  MSG  = "Request to EXIT thread received."
                  IERR = GOS_ERROR(SRN,TRIM(MSG),0)
                  MSG  = "Data Acquisition Thread terminates."
                  IERR = GOS_ERROR(SRN,TRIM(MSG),1)
                  exit    
                ENDIF 
		IF (GPR10_CTRL%QUIT)then   !panic abort
                  MSG  = "Request to QUIT/ABORT thread received."
                  IERR = GOS_ERROR(SRN,TRIM(MSG),0)
                  MSG  = "Data Acquisition Thread terminates."
                  IERR = GOS_ERROR(SRN,TRIM(MSG),1)
		  GPR10_CTRL%RUN_STATUS=.FALSE.     !RUN NOT IN PROGRESS.
	    	  gon_ctrl%pr10_active=gpr10_ctrl%run_status
		  call gbm_flush(jerr)
!HJR		  call ccfini(branch)		   	  !Disconnect from camac
		  call ccfini			   	  !Disconnect from camac
		  return
		endif
			!If we have a nitrogen run, pause the run every time we 
			!are about to process the data
      		if(gpr10_ctrl%nitrogen_run)then
			CALL GPR10_REQUEST_PAUSE	!Ask LP's to leave 
							!event gate closed
			call gpr10_n2_off	!Turn off N2 pulsar(even if its
						!already off, dosen't hurt).
                endif

		CALL GPR10_READ_CAMAC(got_data)  !Get LP memory 

		if(restart_run)then		!Big time screwup. reinit all
			call gpr10_restart	!Clears all buffers reinits
						!camac
			got_data=.false.
		endif
		if(got_data)then
			CALL GPR10_MERGE_DATA(ierr)  !Merge data
			if(restart_run)then	     !Big time screwup.
			    call gpr10_restart       !Clears all buffers reinits
						     !camac
			elseif (ierr) then           !Kill RUN
                          MSG  = "Failed to merge data records."
                          IERR = GOS_ERROR(SRN,TRIM(MSG),1)
                          MSG  = "Data Acquisition Thread terminates."
                          IERR = GOS_ERROR(SRN,TRIM(MSG),1)
			  GPR10_CTRL%RUN_STATUS=.FALSE.
			  gon_ctrl%pr10_active=gpr10_ctrl%run_status
			  call gbm_flush(jerr)
!HJR			  call ccfini(branch)   	  !Disconnect from camac
			  call ccfini		  !Disconnect from camac
			  return
			endif
	       !Panic abort

	      		if(gpr10_ctrl%nitrogen_run)then
!Glenns'fix 			call gpr10_wait(1.0)	!Give gr_an enough time
							!to write events to disk
                                call gpr10_wait(1.0) !SMB 16.2.99 - why was
                                                     !"Glenn's fix" commented out?
		 		CALL GPR10_OPEN_GATE    ! open gate. THis
						   	!enables events
			endif	
		endif
	    else
                MSG  = "Time to terminate run reached."
                IERR = GOS_ERROR(SRN,TRIM(MSG),0)
		exit		!Time to terminate.
	    endif
	ENDDO

!---- termination 
	call gpr10_n2_off	!Turn off N2 pulsar(even if its already off, 
				!dosen't hurt).
	CALL GPR10_REQUEST_PAUSE!Ask LP's to leave event gate closed
    	CALL GPR10_READ_CAMAC(got_data)      !read remaining data 
	IF (GPR10_CTRL%QUIT.or.restart_run)then	       !Panic abort
                MSG  = "Aborting run termination."
                IERR = GOS_ERROR(SRN,TRIM(MSG),1)
                MSG  = "Data Acquisition Thread terminates."
                IERR = GOS_ERROR(SRN,TRIM(MSG),1)
		GPR10_CTRL%RUN_STATUS=.FALSE.     !RUN NOT IN PROGRESS.
		gon_ctrl%pr10_active=gpr10_ctrl%run_status
		call gbm_flush(jerr)
!HJR		call ccfini(branch)		  !Disconnect from camac
		call ccfini			  !Disconnect from camac
		return
	endif

	if(got_data)then
		CALL GPR10_MERGE_DATA(ierr)      !merge remaining data 
		if (ierr.or.restart_run) then    !Kill RUN
                   MSG  = "Failed to merge remaining data records."
                   IERR = GOS_ERROR(SRN,TRIM(MSG),1)
                endif 
	endif
	GPR10_CTRL%RUN_STATUS=.FALSE.     !RUN NOT IN PROGRESS.
	gon_ctrl%pr10_active=gpr10_ctrl%run_status
	call gbm_flush(jerr)
!HJR	call ccfini(branch)		  !Disconnect from camac
	call ccfini			  !Disconnect from camac

	print *,BELL
	print *,BELL
        IERR = GOS_ERROR(SRN,"Run Ended--Thank you very much",0)

	return
    END SUBROUTINE GPR10_START
!*****************************************************************************

    SUBROUTINE GPR10_INIT(ierr)
!-------------------------------------------------------------------------------
! 	This routine_ does some of the stuff we need to do to prepare for
! 	data taking on the 10m. 
!-------------------------------------------------------------------------------
!       This includes:
!      	1.Define all external Register constants need for computer to give
!	  Camac commands.(This really only needs to be done once on the start
!	  of the program but keep it here for clarity).
!	2.Connect to CAMAC ECC manager process.
!	3.Compile and Build (but not load) the list processor programs.
!	4.Initalize all the camac modulas and crates. This include loading
!	  CFD threholds and the Trigger Pattern unit memory(?).
!	5. Clear all input sob channels.
!-------------------------------------------------------------------------------
!	Written by:
!		Glenn Sembroski
!		Physics Dept.
!		Purdue Univ.
!		W.Lafayette, In 47907
!		765-494-5172
!		31/7/97
!	Modified:

!	19/5/99,21/8/99 GHS
!       	Added stuff for crate 2 for 490 pixel upgrade. All new stuff 
!		will test for lp2 online to activate.

!       13/03/02 GHS
!               Add a 'slot' argument to GPR10_SET_DISCS. A value of -1 means
!               update all cfd slots. Otherwise only update/set that slot. Do
!               this to spped up the GPR10_SET_MASK routine

!-------------------------------------------------------------------------------

	use camac_def

	IMPLICIT NONE 
	logical,intent(out):: ierr
	

	character(len=15),PARAMETER :: SRN="GPR10_INIT"
	character(len=80) :: msg
	INTEGER*4 ::  i,j,error
	
	ierr=.false.


!Crate 1
    !LIST_PROC_1
	call cdreg(list_proc_1%ext_reg_code( a0),branch,list_proc_1%crate, &
		list_proc_1%slot, a0)
	call cdreg(list_proc_1%ext_reg_code( a1),branch,list_proc_1%crate, &
		list_proc_1%slot, a1)
	call cdreg(list_proc_1%ext_reg_code( a2),branch,list_proc_1%crate, &
		list_proc_1%slot, a2)
	call cdreg(list_proc_1%ext_reg_code( a3),branch,list_proc_1%crate, &
		list_proc_1%slot, a3)
	call cdreg(list_proc_1%ext_reg_code(a12),branch,list_proc_1%crate, &
		list_proc_1%slot,a12)
	call cdreg(list_proc_1%ext_reg_code(a15),branch,list_proc_1%crate, &
		list_proc_1%slot,a15)
    !SOB1
!Remember:Never use sob-a0-out! see comment for 17/9/97 ghs
	call cdreg(sob1%ext_reg_code(a0),branch,sob1%crate,sob1%slot,a0)
	call cdreg(sob1%ext_reg_code(a1),branch,sob1%crate,sob1%slot,a1)
								!O=ready
	call cdreg(sob1%ext_reg_code(a2),branch,sob1%crate,sob1%slot,a2)
					!O=Turn on N2 Pulser.
	call cdreg(sob1%ext_reg_code(a3),branch,sob1%crate,sob1%slot,a3)
					!O=Turn off N2 Pulser.
	call cdreg(sob1%ext_reg_code(a4),branch,sob1%crate,sob1%slot,a4)
					!O=Generate Pedestal etrigger.
	call cdreg(sob1%ext_reg_code(a5),branch,sob1%crate,sob1%slot,a5)
	call cdreg(sob1%ext_reg_code(a6),branch,sob1%crate,sob1%slot,a6)
	call cdreg(sob1%ext_reg_code(a7),branch,sob1%crate,sob1%slot,a7)
    !ADC1 
	do i=1,nadc1
       call cdreg(adc1(i)%ext_reg_code(a0),branch,adc1(i)%crate,adc1(i)%slot,a0)
	enddo

    !MALU1
       call cdreg(malu1%ext_reg_code(a0),branch,malu1%crate,malu1%slot,a0)



!Crate 2
    !LIST_PROC_2
	call cdreg(list_proc_2%ext_reg_code( a0),branch,list_proc_2%crate, &
		list_proc_2%slot, a0)
	call cdreg(list_proc_2%ext_reg_code( a1),branch,list_proc_2%crate, &
		list_proc_2%slot, a1)
	call cdreg(list_proc_2%ext_reg_code( a2),branch,list_proc_2%crate, &
		list_proc_2%slot, a2)
	call cdreg(list_proc_2%ext_reg_code( a3),branch,list_proc_2%crate, &
		list_proc_2%slot, a3)
	call cdreg(list_proc_2%ext_reg_code(a12),branch,list_proc_2%crate, &
		list_proc_2%slot,a12)
	call cdreg(list_proc_2%ext_reg_code(a15),branch,list_proc_2%crate, &
		list_proc_2%slot,a15)
    !SOB2
    !Remember:Never use sob-a0-out! see comment for 17/9/97 ghs
	call cdreg(sob2%ext_reg_code(a0),branch,sob2%crate,sob2%slot,a0)
	call cdreg(sob2%ext_reg_code(a1),branch,sob2%crate,sob2%slot,a1)
								!O=ready
	call cdreg(sob2%ext_reg_code(a2),branch,sob2%crate,sob2%slot,a2)
	call cdreg(sob2%ext_reg_code(a3),branch,sob2%crate,sob2%slot,a3)
	call cdreg(sob2%ext_reg_code(a4),branch,sob2%crate,sob2%slot,a4)
	call cdreg(sob2%ext_reg_code(a5),branch,sob2%crate,sob2%slot,a5)
	call cdreg(sob2%ext_reg_code(a6),branch,sob2%crate,sob2%slot,a6)
	call cdreg(sob2%ext_reg_code(a7),branch,sob2%crate,sob2%slot,a7)
    !ADC2 
	do i=1,nadc2
       call cdreg(adc2(i)%ext_reg_code(a0),branch,adc2(i)%crate,adc2(i)%slot,a0)
	enddo

    !MALU2
       call cdreg(malu2%ext_reg_code(a0),branch,malu2%crate,malu2%slot,a0)
	

!Crate 3
    !LIST_PROC_3
	call cdreg(list_proc_3%ext_reg_code( a0),branch,list_proc_3%crate, &
		list_proc_3%slot, a0)
	call cdreg(list_proc_3%ext_reg_code( a1),branch,list_proc_3%crate, &
		list_proc_3%slot, a1)
	call cdreg(list_proc_3%ext_reg_code( a2),branch,list_proc_3%crate, &
		list_proc_3%slot, a2)
	call cdreg(list_proc_3%ext_reg_code( a3),branch,list_proc_3%crate, &
		list_proc_3%slot, a3)
	call cdreg(list_proc_3%ext_reg_code(a12),branch,list_proc_3%crate, &
		list_proc_3%slot,a12)
	call cdreg(list_proc_3%ext_reg_code(a15),branch,list_proc_3%crate, &
		list_proc_3%slot,a15)
    !SOB3
!Remember:Never use sob-a0-out! see comment for 17/9/97 ghs
	call cdreg(sob3%ext_reg_code(a0),branch,sob3%crate,sob3%slot,a0)
!I=Terminate Data ACQ Request computer to LP3 (from sob3-a3-out)
	call cdreg(sob3%ext_reg_code(a1),branch,sob3%crate,sob3%slot,a1)
		!I=SOB1 ready(from sob1-a1-out:   	O=Open Event Gate
	call cdreg(sob3%ext_reg_code(a2),branch,sob3%crate,sob3%slot,a2)
		!I=SOB2 ready(from sob2-a1-out: 	O=Close Event Gate
	call cdreg(sob3%ext_reg_code(a3),branch,sob3%crate,sob3%slot,a3)
!O=Terminate Data ACQ Request from Computer(to sob3-a0-in)
	call cdreg(sob3%ext_reg_code(a4),branch,sob3%crate,sob3%slot,a4)
		!I=SOB4 ready(from sob4-a1-out)
	call cdreg(sob3%ext_reg_code(a5),branch,sob3%crate,sob3%slot,a5)
		!O=Clear event count generator.
	call cdreg(sob3%ext_reg_code(a6),branch,sob3%crate,sob3%slot,a6)
!I=Termination Request Accepted to computer.(from sob3-a6-out)
!O=Termination Request Accepted from LP3.(to sob3-a6-in)
	call cdreg(sob3%ext_reg_code(a7),branch,sob3%crate,sob3%slot,a7)

    !ADC3 
	do i=1,nadc3
       call cdreg(adc3(i)%ext_reg_code(a0),branch,adc3(i)%crate,adc3(i)%slot,a0)
	enddo
    !RA: encoder register (lecroy 2341)
       call cdreg(ra%ext_reg_code(a0),branch,ra%crate,ra%slot,a0)
    !DEC: encoder register (lecroy 2341)
       call cdreg(dec%ext_reg_code(a0),branch,dec%crate,dec%slot,a0)


    !Hytec GPS clock
       call cdreg(hytec_gps%ext_reg_code(a0),branch,hytec_gps%crate,  &
	        & hytec_gps%slot,a0)

    !Trigger unit (lecroy 2341)
       call cdreg(trigger%ext_reg_code( a0),branch,trigger%crate,trigger%slot,&
		& a0)
	
   !MALU3
       call cdreg(malu3%ext_reg_code(a0),branch,malu3%crate,malu3%slot,a0)

!Crate 4
    !LIST_PROC_4
	call cdreg(list_proc_4%ext_reg_code( a0),branch,list_proc_4%crate, &
		list_proc_4%slot, a0)
	call cdreg(list_proc_4%ext_reg_code( a1),branch,list_proc_4%crate, &
		list_proc_4%slot, a1)
	call cdreg(list_proc_4%ext_reg_code( a2),branch,list_proc_4%crate, &
		list_proc_4%slot, a2)
	call cdreg(list_proc_4%ext_reg_code( a3),branch,list_proc_4%crate, &
		list_proc_4%slot, a3)
	call cdreg(list_proc_4%ext_reg_code(a12),branch,list_proc_4%crate, &
		list_proc_4%slot,a12)
	call cdreg(list_proc_4%ext_reg_code(a15),branch,list_proc_4%crate, &
		list_proc_4%slot,a15)
    !SOB4
!Remember:Never use sob-a0-out! see comment for 17/9/97 ghs
	call cdreg(sob4%ext_reg_code(a0),branch,sob4%crate,sob4%slot,a0)
	call cdreg(sob4%ext_reg_code(a1),branch,sob4%crate,sob4%slot,a1)
	call cdreg(sob4%ext_reg_code(a2),branch,sob4%crate,sob4%slot,a2)
								!O=ready
	call cdreg(sob4%ext_reg_code(a3),branch,sob4%crate,sob4%slot,a3)
!O=Strobe IRQ line of GRS2 to read GPS under computer control:SYNCH command.
!		This output is inverted to get correct polarity.
	call cdreg(sob4%ext_reg_code(a4),branch,sob4%crate,sob4%slot,a4)
	call cdreg(sob4%ext_reg_code(a5),branch,sob4%crate,sob4%slot,a5)
	call cdreg(sob4%ext_reg_code(a6),branch,sob4%crate,sob4%slot,a6)
	call cdreg(sob4%ext_reg_code(a7),branch,sob4%crate,sob4%slot,a7)
    !MALU4
       call cdreg(malu4%ext_reg_code(a0),branch,malu4%crate,malu4%slot,a0)

	!MICH_OSC
   call cdreg(mich_osc%ext_reg_code(a0),branch,mich_osc%crate,mich_osc%slot,a0)
   call cdreg(mich_osc%ext_reg_code(a1),branch,mich_osc%crate,mich_osc%slot,a1)
   call cdreg(mich_osc%ext_reg_code(a2),branch,mich_osc%crate,mich_osc%slot,a2)
   call cdreg(mich_osc%ext_reg_code(a3),branch,mich_osc%crate,mich_osc%slot,a3)


    !GRS2:GPS Satelite clock Wisconsin gamma * interface 24 bit readout
       call cdreg(grs2%ext_reg_code(a2),branch,grs2%crate,grs2%slot, a2)
    !LIVE_TIME
		!Encode for Live Time Scaler
	call cdreg(live_time%ext_reg_code( a0),branch,live_time%crate, &
		& live_time%slot, a0) !livetime
    !PST:Pattern Selection Trigger
	do i=1,npst
		do j=0,4
			call cdreg(pst(i)%ext_reg_code(j),branch,pst(i)%crate,&
			 & pst(i)%slot,j)
		enddo

		call cdreg(pst(i)%ext_reg_code(a15),branch,pst(i)%crate,&
			 & pst(i)%slot,a15)
	enddo


!Crate 5
!LIST_PROC_5
	call cdreg(list_proc_5%ext_reg_code( a0),branch,list_proc_5%crate, &
		list_proc_5%slot, a0)           
	call cdreg(list_proc_5%ext_reg_code( a1),branch,list_proc_5%crate, &
		list_proc_5%slot, a1)
	call cdreg(list_proc_5%ext_reg_code( a1),branch,list_proc_5%crate, &
		list_proc_5%slot, a1)
	call cdreg(list_proc_5%ext_reg_code( a2),branch,list_proc_5%crate, &
		list_proc_5%slot, a2)
	call cdreg(list_proc_5%ext_reg_code( a3),branch,list_proc_5%crate, &
		list_proc_5%slot, a3)
	call cdreg(list_proc_5%ext_reg_code(a12),branch,list_proc_5%crate, &
		list_proc_5%slot,a12)
	call cdreg(list_proc_5%ext_reg_code(a15),branch,list_proc_5%crate, &
		list_proc_5%slot,a15)
    !SOB5
!Remember:Never use sob-a0-out! see comment for 17/9/97 ghs
	call cdreg(sob5%ext_reg_code(a0),branch,sob5%crate,sob5%slot,a0)
							!I=Pedestal event flag
	call cdreg(sob5%ext_reg_code(a1),branch,sob5%crate,sob5%slot,a1)
	call cdreg(sob5%ext_reg_code(a2),branch,sob5%crate,sob5%slot,a2)
	call cdreg(sob5%ext_reg_code(a3),branch,sob5%crate,sob5%slot,a3)
	call cdreg(sob5%ext_reg_code(a4),branch,sob5%crate,sob5%slot,a4)
	call cdreg(sob5%ext_reg_code(a5),branch,sob5%crate,sob5%slot,a5)
	call cdreg(sob5%ext_reg_code(a6),branch,sob5%crate,sob5%slot,a6)
	call cdreg(sob5%ext_reg_code(a7),branch,sob5%crate,sob5%slot,a7)
!MALU5
       call cdreg(malu5%ext_reg_code(a0),branch,malu5%crate,malu5%slot,a0)

!Lecroy 4431 scaler
	do i=1,n_lecroy_scaler
		call cdreg(lscal(i)%ext_reg_code(a0),branch,lscal(i)%crate, &
		lscal(i)%slot,a0)           
	enddo
!Phillips scaler
	do i=1,n_phillips_scaler
		call cdreg(pscal(i)%ext_reg_code(a4),branch,pscal(i)%crate, &
		pscal(i)%slot,a4)           
	enddo

!crate 6
!CFD's
	do i=1,n_cfd_discriminators
		do j=0,n_cfd_chan-1
			call cdreg(cfd(i)%ext_reg_code(j),branch,cfd(i)%crate, &
		  	& cfd(i)%slot,j)           
		enddo
	enddo

!	Initialise (make a connection to) the ecc manager
	call ccinit(BRANCH) 


!Init crates:	Generate Z,C,Turn off inhibit, Disable triggers
	call gpr10_crate_init(list_proc_1,ierr)
	if(ierr)return
	call gpr10_crate_init(list_proc_2,ierr)
	if(ierr)return
	call gpr10_crate_init(list_proc_3,ierr)		!always exits
	if(ierr)return
	call gpr10_crate_init(list_proc_4,ierr)
	if(ierr)return
	call gpr10_crate_init(list_proc_5,ierr)
	if(ierr)return



!Close the event gate by sending pulse through sob3-A2-out
	status=fcssa(f25,sob3%ext_reg_code(a2),w_data_i2,q)
	if(.not.btest(status,0)) call gos_signal(srn,status)

!	Test list processors in all crates. Book them.
!	LP don't know who books them but they have to be booked for
!	triggers.

	call gpr10_lp_unbook(list_proc_1,ierr)
	if(ierr)return
	call gpr10_lp_unbook(list_proc_2,ierr)
	if(ierr)return
	call gpr10_lp_unbook(list_proc_3,ierr)		!Always exits
	if(ierr)return
	call gpr10_lp_unbook(list_proc_4,ierr)
	if(ierr)return
	call gpr10_lp_unbook(list_proc_5,ierr)
	if(ierr)return


!************Start LP program generation*****************************
!	The programs to be loaded into the LP's is first "assembled" into 
!	arrays lp1%inst,lp2%inst,lp3%inst,lp4%inst,lp5%inst.  These programs
!	arrays will be down  "loaded"  into the appropriate Lp's.

	call gpr10_lp_build

!	Load the list processor  programs.
	call gpr10_lp_load(lp1,list_proc_1)
	call gpr10_lp_load(lp2,list_proc_2)
	call gpr10_lp_load(lp3,list_proc_3)			!always exits
	call gpr10_lp_load(lp4,list_proc_4)
	call gpr10_lp_load(lp5,list_proc_5)

!Note:: GPR10_LP_BUILD writes "listings" of the lp programs to
!	files: LP1_PROGRAM.LIS,LP2_PROGRAM.LIS,LP3_PROGRAM.LIS
!      	LP4_PROGRAM.LIS and LP5_PROGRAM.LIS

!Init lp registers (Memory Read, write and instruction=0, clear all SOB
!	input.
	call gpr10_init_lp_sob(list_proc_1,sob1)
	call gpr10_init_lp_sob(list_proc_2,sob2)
	call gpr10_init_lp_sob(list_proc_3,sob3)	!always exits
	call gpr10_init_lp_sob(list_proc_4,sob4)
	call gpr10_init_lp_sob(list_proc_5,sob5)



!	Setup CFD discriminators.
	CALL GPR10_SET_DISCS(-1)

!Malu1	  
	if(list_proc_1%online)then
		status=fcssa(f9,malu1%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif
!Malu2	  
	if(list_proc_2%online)then
		status=fcssa(f9,malu2%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif
!Malu3	       
     	status=fcssa(f9,malu3%ext_reg_code(a0),w_data_i2,q)
     	if(.not.btest(status,0)) call gos_signal(srn,status)
!Malu4	       
	if(list_proc_4%online)then
		status=fcssa(f9,malu4%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif
!Malu5	       
	if(list_proc_5%online)then
		status=fcssa(f9,malu5%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif
!RA encoder register(lecroy 2341)
	if(ra%online)then
		status=fcssa(f9,ra%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

!DEC encoder register(lecroy 2341)
	if(dec%online)then
		status=fcssa(f9,dec%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif
!LIVE TIME Scaler
!	If we are not in a RESTART mode,Clear LIVE_TIME scaler(all channels)
!	and clear the event counter.
	if(.not.restart_run)then
		if(live_time%online)then
			status=fcssa(f9,live_time%ext_reg_code(0),w_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
		endif
		status=fcssa(f25,sob3%ext_reg_code(a5),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)

		da_next_event=0		!First event number we expect.
		da_last_event=-1	!Last event number we processed.
		live_sec_old=0		!Use to moniter scalers
	endif
	restart_run=.false.

!Hytec GPS
	if(hytec_gps%online)then
			!Reset Hytec GOS page register.
!		status=fcssa(f18,hytec_gps%ext_reg_code(a0),w_data_i2,q)
!		if(.not.btest(status,0)) call gos_signal(srn,status)
			!Clear LAM
		status=fcssa(f10,hytec_gps%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
			!Enable LAM
		status=fcssa(f26,hytec_gps%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

!Event Trigger Unit
!	Clear trigger unit(lecroy 2341)
	if(trigger%online)then
		status=fcssa(f9,trigger%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

!Clear the ADC's in crates 1 2, and 3 and then enable their LAMs. The LAM flags
!indicate during data taking when conversion is done. Note that this
!use of f9 in this adc module always returns q=0.

	if(list_proc_1%online)then
	    do i=1,nadc1
		if(adc1(i)%online)then
			status=fcssa(f9,adc1(i)%ext_reg_code(a0),w_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
			status=fcssa(f26,adc1(i)%ext_reg_code(a0),w_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
		endif
	    enddo
	endif

	if(list_proc_2%online)then
	    do i=1,nadc2
		if(adc2(i)%online)then
			status=fcssa(f9,adc2(i)%ext_reg_code(a0),w_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
			status=fcssa(f26,adc2(i)%ext_reg_code(a0),w_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
		endif
	    enddo
	endif

	do i=1,nadc3
		if(adc3(i)%online)then
			status=fcssa(f9,adc3(i)%ext_reg_code(a0),w_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
			status=fcssa(f26,adc3(i)%ext_reg_code(a0),w_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
		endif
	enddo

        
!22/8/99 GHS MICH_OSC removed some time ago.
!!Init Micichgan oscillator,. This is extreamly temprory.
!	if(mich_osc%online)then
!						!Disable event clock
!	    status=fcssa(f24,mich_osc%ext_reg_code(a0),w_data_i2,q)
!	    if(.not.btest(status,0)) call gos_signal(srn,status)
!						!Switch to internal clock
!	    status=fcssa(f24,mich_osc%ext_reg_code(a1),w_data_i2,q)
!	    if(.not.btest(status,0)) call gos_signal(srn,status)
!						!Disable event clock 
!	    status=fcssa(f24,mich_osc%ext_reg_code(a2),w_data_i2,q)
!	    if(.not.btest(status,0)) call gos_signal(srn,status)
!						!Disable event clock 
!	    status=fcssa(f24,mich_osc%ext_reg_code(a3),w_data_i2,q)
!	    if(.not.btest(status,0)) call gos_signal(srn,status)
!						!toggle switch
!	    status=fcssa(f9,mich_osc%ext_reg_code(a0),w_data_i2,q)
!	    if(.not.btest(status,0)) call gos_signal(srn,status)
!						!Clear event clock counter
!	    status=fcssa(f9,mich_osc%ext_reg_code(a1),w_data_i2,q)
!	    if(.not.btest(status,0)) call gos_signal(srn,status)
!					!Enable 20 Mhz clock train.
!	    status=fcssa(f26,mich_osc%ext_reg_code(a0),w_data_i2,q)
!	    if(.not.btest(status,0)) call gos_signal(srn,status)
!       endif


!INit GRS2 gps clock interface(clear it)
	if(grs2%online)then
		status=fcssa(f2,grs2%ext_reg_code(a2),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

!PST patch enable.
!	The patch memories have been previously loaded before this thread was
!started. At that time the reference level is also set for the majority logic
!comparator(See command SET/PST/MULT and routine GPR10_SET_PST).
 	do i=1,npst
		if(pst(i)%online)then
		   status=fcfsa(f25,pst(i)%ext_reg_code(a15),w_data_i4,q)
		   if(.not.btest(status,0)) call gos_signal(srn,status)

       	        do j=0,4
			status=fcfsa(f26,pst(i)%ext_reg_code(j),w_data_i4,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
                   enddo
		endif
	enddo
!At this point, any input pulses will be captured if they satisfy the majority
!logic comparitor and match a pre-loaded 'interesting' pattern.
!However when sob3-a1-out is generated to open the event gate it also generates
!a Global Enable pulse to all PST's that clears any pre-existing patch flags.


!Init Lecroy 4434 singles scalers. LOad command register with
!FA(first address)=0,RN(Readout number-1)=31,RD(REadout enable)=1
	w_data_i2=31*(2**8)+1*(2**7)
					!Load Scaler command regs
	do i=1,n_lecroy_scaler
		if(lscal(i)%online)then
			status=fcssa(f16,lscal(i)%ext_reg_code(a0),w_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
		endif   
	enddo

!Init Phillips scalers.
 	do i=1,n_phillips_scaler
		if(pscal(i)%online)then
			status=fcfsa(f11,pscal(i)%ext_reg_code(a4),w_data_i4,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
		endif   
	enddo

	!Init index pointers to computer data buffer for start of new run.
	lp1%start=0
	lp2%start=0
	lp3%start=0
	lp4%start=0
	lp5%start=0

	lp1%buf_empty=.true.      !drops any old data during a restart.
	lp2%buf_empty=.true.      !drops any old data during a restart.
	lp3%buf_empty=.true.      !drops any old data during a restart.
	lp4%buf_empty=.true.      !drops any old data during a restart.
	lp5%buf_empty=.true.      !drops any old data during a restart.

!	Enable the lp triggers. At this time the PMT gate is closed
!	and we should be ready to start.

	if(list_proc_1%online)then
		status=fcssa(f26,list_proc_1%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

	if(list_proc_2%online)then
		status=fcssa(f26,list_proc_2%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

	status=fcssa(f26,list_proc_3%ext_reg_code(a0),w_data_i2,q)
	if(.not.btest(status,0)) call gos_signal(srn,status)

	if(list_proc_4%online)then
		status=fcssa(f26,list_proc_4%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

	if(list_proc_5%online)then
		status=fcssa(f26,list_proc_5%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

!	The list processors are waiting for a trigger
!	The camac has the event gate closed and all modules are
!	ready for events.
!	In short: WE'RE HOT!


	return

    END SUBROUTINE GPR10_INIT
!*****************************************************************************

    SUBROUTINE GPR10_LP_LOAD(lp,list_proc)
!	Load a program into a list processor from 
!	array lp%INST starting at address 0 to address 8191.
	use camac_def

        IMPLICIT NONE 
	type(lp_data) :: lp
	type(camac_module) :: list_proc

	integer*4,dimension(4) :: cb
	character(len=13),PARAMETER :: SRN="GPR10_LP_LOAD"
 

	if(list_proc%online)then
!	Disable trigger in list processor just in case.
		status=fcssa(f24,list_proc%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)

!	Set lp intruction counter to 0.
		w_data_i2=0
		status=fcssa(f17,list_proc%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)

!	Load the program
		cb(1)=8191+1
		cb(2)=0
		cb(3)=0
		cb(4)=0
		status=fcsubr(f16,list_proc%ext_reg_code(a0),lp%inst,cb)
		if(.not.btest(status,0)) call gos_signal(srn,status)

!	Reset instruction pointer to 0.
		w_data_i2=0
		status=fcssa(f17,list_proc%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif
	return
    END SUBROUTINE GPR10_LP_LOAD
!*****************************************************************************

    SUBROUTINE GPR10_LP_BUILD
!-------------------------------------------------------------------------------
!	Build the programs for the LIST PROCESSORS for the 10m.
!-------------------------------------------------------------------------------
!	Written by:
!		Glenn Sembroski
!		Physics Dept.
!		Purdue Univ.
!		W.Lafayette, In 47907
!		765-494-5172
!		06/8/97
!-------------------------------------------------------------------------------
!	Modified:


!These programs are "compiled" by use of function subroutines from Module
! LP_COMMANDS. These routines return the appropriate integer value of an
! instruction to be downloaded to the LP instruction memory. Most of the LP
! commands are "FNA" (Function, Slot(N), sub-Address) or ordinary camac read 
! or control type commands. There
! are also some test-and-jump type commands that give the LP's a small
! ammount of smarts. For example the LP can loop on a "TEST LAM" FNA command
! given to an ADC module by Jumping back to the test command if no Q is
! given by the module. No q indicates the ADC is not yet ready to be read out
! (conversion is still in progress).
!***************************************************************************
!	If you want to change the programing in the LP's, this is where you
!	do it!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***************************************************************************

!NOTES
!***************************************************************************
!Note#1: Limitation of LP's: Due to a funny design "feature" in the List
!      Processors only locations in lowest 2048 words of memory can
!	be jumped to. All JMP addresses must be <12 bits.(3777)octal
!***************************************************************************
!***************************************************************************
!Note#2: Do to another funny design "feature" in the List  Processors we must
!	Init all address in the jump table(see below)table to have bit 4 
!	(10 octal) on.
!	This prevents memory pointer incrimentation when the list is
!	being searched for source of a trigger(screwy HYtec problem).
!***************************************************************************
!***************************************************************************
!Note#3: Another feature(related to the one above). It is important to make sure
! that the target address of any jmp command that does a test (jmpnoq etc.)
! has bit 4 (10 octal) set. If the target addres doesn't have this bit on this
! funny Hytec "feature" will incriment the write memory address counter 
! each time the jump to that location is executed if that bit wasn't set. 
! (for the technically inclined: Note that bit 4 is the non-data-transfer bit
! in FNA commands. Basically Hytec just checks the status of this bit and the
! 1 bit to tell if the write pointer should be incrimented. Of course the
! design should have done this only for FNA commands but it apparently does it
! for jump commands also! :(  Very weird bug!)
!***************************************************************************
	use camac_def
	use lp_commands

        IMPLICIT NONE 
		
	character(len=14),PARAMETER :: SRN="GPR10_LP_BUILD"
	character(len=80) :: msg

	integer*2 :: read_tag
        INTEGER :: m,m1,I,j 
        INTEGER :: NCHAN
	integer :: trigger1=0
	
	lp1%tag_count=0		!Init tag counters
	lp2%tag_count=0
	lp3%tag_count=0
	lp4%tag_count=0
	lp5%tag_count=0
	
	lp1%event_length=0	!Number of words readout in an event in each
	lp2%event_length=0	!crate.
	lp3%event_length=0	!crate.
	lp4%event_length=0	!Trigger pattern unit is variable.Must be
				!handled differently
	lp5%event_length=0
!	The programs to be loaded into List Processors are first "assembled" 
!	into the instruction arrays (lp1%inst,lp2%inst,lp3%inst etc.).  The 
!	locations in
!	these arrays corespond to the memory locations the instructions will be
!	loaded into in the List Processors.
!First Initalize all the instruction memory buffers with some error checking 
! stuff.
	call gpr10_lp_build_init(lp1)
	call gpr10_lp_build_init(lp2)
	call gpr10_lp_build_init(lp3)
	call gpr10_lp_build_init(lp4)
	call gpr10_lp_build_init(lp5)

!***************************************************************
!CRATE 1
!***************************************************************
!Start LP crate 1 program
!	The lowest 7 (0-6)addresses are a jump table for the various
!	triggers. We only use 1 trigger in LP1  
!		Trigger#1 : Normal trigger: 
! 				1:Get tag
!				2:Read evnet number from MALU1
!				3:Readout all ADC's
!				4:Send flag through SOB1 to SOB3 that this
!				  crate is done.



!	Define a the list processor intruction pointer read command. This
!	This command is used to "tag" the data. It is also used to put in
!	a "place" value in the data stream when a camac module is to be skipped
	read_tag=fna(f1,list_proc_1%slot,a0) 

!Normal event readout. Jumped to when lp1 trigger#1 occurs (normal or
!pedestal event) 

!Start program
	m=9				!First address with bit 4 (10 octal) on
					!Needed for all addresses in jmp table
	lp1%inst(trigger1)=jmp(m)	!Set jump table address.

	lp1%tag_count=lp1%tag_count+1
	lp1%tag(lp1%tag_count)=m  	!Save trigger tag value

	lp1%inst(m)=read_tag		!Get tag address for this list processor
	lp1%slot_used(m)=list_proc_1%slot
	lp1%device(m)="Read LP TAG"
	lp1%event_length=1		!Count it
	m=m+1				!trigger.


!Read event number from MALU
	call gpr10_lp_build_malu(malu1,lp1,m)

!Read out ADC's
	call gpr10_lp_build_adc(adc1,lp1,m,nadc1)

!we are now done with reading out this crate. Generate the all done flag for
!the program in LP3 which will open event gate when all data for this event
!is read in.

	lp1%inst(m)=fna(f25,sob1%slot,a1)	!Set all done flag. 
						!SOB1-a1-out is connected to
						!SOB3-a1-in
	lp1%slot_used(m)=sob1%slot
	lp1%device(m)=sob1%dev_type
	m=m+1
	
	lp1%inst(m)=jmpawt(0)			!go wait for next event

	lp1%last=m				!Save last address for listing
						!generation
!Write out program listing
	open(12,file="LP1_program.lis",status="REPLACE")
	call gpr10_lp_dump(lp1)
	close(12)


!***************************************************************
!CRATE 2
!***************************************************************
!Start LP crate 2 program
!	The lowest 7 (0-6)addresses are a jump table for the various
!	triggers. We only use 1 trigger in LP2  
!		Trigger#1 : Normal trigger: 
! 				1:Get tag
!				2:Read evnet number from MALU2
!				3:Readout all ADC's
!				4:Send flag through SOB2 to SOB3 that this
!				  crate is done.



!	Define a the list processor intruction pointer read command. This
!	This command is used to "tag" the data. It is also used to put in
!	a "place" value in the data stream when a camac module is to be skipped
	read_tag=fna(f1,list_proc_2%slot,a0) 

!Normal event readout. Jumped to when lp2 trigger#1 occurs (normal or
!pedestal event) 

!Start program
	m=9				!First address with bit 4 (10 octal) on
					!Needed for all addresses in jmp table
	lp2%inst(trigger1)=jmp(m)	!Set jump table address.

	lp2%tag_count=lp2%tag_count+1
	lp2%tag(lp2%tag_count)=m  	!Save trigger tag value

	lp2%inst(m)=read_tag		!Get tag address for this list processor
	lp2%slot_used(m)=list_proc_2%slot
	lp2%device(m)="Read LP TAG"
	lp2%event_length=1		!Count it
	m=m+1				!trigger.


!Read event number from MALU
	call gpr10_lp_build_malu(malu2,lp2,m)

!Read out ADC's
	call gpr10_lp_build_adc(adc2,lp2,m,nadc2)

!we are now done with reading out this crate. Generate the all done flag for
!the program in LP3 which will open event gate when all data for this event
!is read in.

	lp2%inst(m)=fna(f25,sob2%slot,a1)	!Set all done flag. 
						!SOB2-a1-out is connected to
						!SOB3-a2-in
	lp2%slot_used(m)=sob2%slot
	lp2%device(m)=sob2%dev_type
	m=m+1
	
	lp2%inst(m)=jmpawt(0)			!go wait for next event

	lp2%last=m				!Save last address for listing
						!generation
!Write out program listing
	open(12,file="LP2_program.lis",status="REPLACE")
	call gpr10_lp_dump(lp2)
	close(12)


!***************************************************************
!CRATE 3
!***************************************************************
!***************************************************************
!Start LP crate 3 program
!	The lowest 7 (0-6)addresses are a jump table for the various
!	triggers. We only use 1 trigger in LP3  
!		Trigger#1 : Normal trigger: 
! 				1:Get tag
!				2:Read evnet number from MALU3
!				3:Readout all ADC's
!				4: Readout all misc modules
!				5: Check all other crates until they are done
!				6: If computer is not requesting termination
!				   of data  acquisition(sob3-a0-in)then
!				7: then:open event gate.
!				8: else: acknowledge recipt of request
!				9:Go await next trigger.


!	Define tag command.
	read_tag=fna(f1,list_proc_3%slot,a0) 

!Normal event readout. Jumped to when lp3 trigger#1 occurs (normal or
!pedestal event) 

!Start program
	m=9				!First address with bit 4 (10 octal) on
					!Needed for all addresses in jmp table
	lp3%inst(trigger1)=jmp(m)		!Set jump table address.

	lp3%tag_count=lp3%tag_count+1
	lp3%tag(lp3%tag_count)=m  	!Save trigger tag value

	lp3%inst(m)=read_tag		!Get tag address for this list processor
	lp3%slot_used(m)=list_proc_3%slot
	lp3%device(m)="Read LP TAG"
	lp3%event_length=1		!Count it
	m=m+1				!trigger.


!Read event number from MALU
	call gpr10_lp_build_malu(malu3,lp3,m)

!Read out ADC's
	call gpr10_lp_build_adc(adc3,lp3,m,nadc3)

!RA:encoder register(Lecroy 2341).
	if(ra%online)then
						!Read and clear RA register
	     	ra%start=lp3%event_length+1  !Location in buffer of first 
						!data word of this module
		lp3%inst(m)=fna(f2,ra%slot,a0)
		lp3%slot_used(m)=ra%slot
		lp3%device(m)=ra%dev_type
		lp3%event_length=lp3%event_length+1
		ra%end=lp3%event_length		!Location in buffer of last 
						!data word of this scaler
		m=m+1
	endif
!DEC:encoder register(Lecroy 2341).
	if(dec%online)then
						!Read and clear DEC register
	     	dec%start=lp3%event_length+1  !Location in buffer of first 
						!data word of this module
		lp3%inst(m)=fna(f2,dec%slot,a0)
		lp3%slot_used(m)=dec%slot
		lp3%device(m)=dec%dev_type
		lp3%event_length=lp3%event_length+1
		dec%end=lp3%event_length	!Location in buffer of last 
						!data word of this scaler
		m=m+1
	endif

!Hytec gps time.
	if(hytec_gps%online)then
!		call gpr10_lp_build_test_q(hytec_gps,lp3,m,f8,a0)  !Test LAM
!		call gpr10_lp_build_test_q(hytec_gps,lp3,m,f27,a0)
							 !Test LAM: Try again
	     	hytec_gps%start=lp3%event_length+1 !Location in buffer of first 
						!data word of this module

!amb 981022	do i=0,5	! only read 4 words of time until I'm sure that
				! reading too much isn't the reason why we are
				! having lots of time gaps when we include this
				! module in the data taking.
		do i=0,3
			lp3%inst(m)=fna(f0,hytec_gps%slot,i) + 16384 
					! read GPS and ignore NOQ
			lp3%slot_used(m)=hytec_gps%slot
			lp3%device(m)=hytec_gps%dev_type
			lp3%event_length=lp3%event_length+1
			m=m+1
		enddo
		hytec_gps%end=lp3%event_length 	!Location in buffer of last 
						!data word of this module

		lp3%inst(m)=fna(f10,hytec_gps%slot,a0)		!clear LAM
		lp3%slot_used(m)=hytec_gps%slot
		lp3%device(m)=hytec_gps%dev_type

		lp3%inst(m)=fna(f26,hytec_gps%slot,a0)		!Enable LAM
		lp3%slot_used(m)=hytec_gps%slot
		lp3%device(m)=hytec_gps%dev_type
	endif

!Trigger unit(Lecroy 2341).
	if(trigger%online)then
						!Read and clear Trigger unit.	
	     	trigger%start=lp3%event_length+1  !Location in buffer of first 
						!data word of this module
		lp3%inst(m)=fna(f2,trigger%slot,a0)
		lp3%slot_used(m)=trigger%slot
		lp3%device(m)=trigger%dev_type
		lp3%event_length=lp3%event_length+1
		trigger%end=lp3%event_length	!Location in buffer of last 
						!data word of this scaler
		m=m+1
	endif

!we are now done with reading out this crate. Now check all the other cratesa
!(lp1 lp2,and lp4. LP5 is scaler crate and
! we really don't have to wait for it.)
!Once all other crates are done open the event gate.


 	if(list_proc_1%online)then
		call gpr10_lp_build_test_q(sob3,lp3,m,f27,a1)!Wait for crate 1
							     ! done
	endif
 	if(list_proc_2%online)then
		call gpr10_lp_build_test_q(sob3,lp3,m,f27,a2)!Wait for crate 2
							     ! done
	endif

 	if(list_proc_4%online)then
		call gpr10_lp_build_test_q(sob3,lp3,m,f27,a4) !Wait for crate 4
							      !done
	endif

	!See if computer is requesting a termination of data acq.SOB3-a0-in
		!If so anknowledge receipt of request back to computer
		!through sob3-a6-out which is tied to sob3-a6-in.
		!first find a good jmp address( see note #3 above)
	call gpr10_lp_build_add_jmp(lp3,m)
       	lp3%inst(m)=fna(f27,sob3%slot,a0)+q_ignore	!Test sob3-a0-in
	lp3%slot_used(m)=sob3%slot
	lp3%device(m)=sob3%dev_type
	m=m+1  
	lp3%inst(m)=jmpnoq(m+3)			!Jump to open event gate if
	m=m+1					!no termination requested.

	lp3%inst(m)=fna(f25,sob3%slot,a6)	!Send back acknowlegment of
	lp3%slot_used(m)=sob3%slot
	lp3%device(m)=sob3%dev_type
	m=m+1					!request of termination.
	lp3%inst(m)=jmpawt(0)			!Go wait for event gate to open
	m=m+1					!by computer.

	lp3%inst(m)=fna(f25,sob3%slot,a1)	!Open event gate.!SOB3-a1-out
	lp3%slot_used(m)=sob3%slot
	lp3%device(m)=sob3%dev_type
	m=m+1
	lp3%inst(m)=jmpawt(0)			!go wait for next event

	lp3%last=m				!Save last address for listing
						!generation
!Write out program listing
	open(12,file="LP3_program.lis",status="REPLACE")
	call gpr10_lp_dump(lp3)
	close(12)


!***************************************************************
!CRATE 4		Trigger Processor crate.
!   Note this crate has all modules that require 24 bit readout
!***************************************************************
!Start LP crate 4 program
!	The lowest 7 (0-6)addresses are a jump table for the various
!	triggers. We only use 1 trigger in LP4  
!		Trigger#1 : Normal trigger: 
! 				1:Get tag
!				2:Read event number from MALU4
!				3:Readout Trigger processors(24 bits)
!				4:Readout GRS2 GPS clock(24 bits)
!				5: Livetime scaler readout.
!				6:Send flag through SOB4 to SOB3 that this
!				  crate is done.



!	Define a the list processor intruction pointer read command. This
!	This command is used to "tag" the data. It is also used to put in
!	a "place" value in the data stream when a camac module is to be skipped
	read_tag=fna(f1,list_proc_4%slot,a0) 

!Normal event readout. Jumped to when lp4 trigger#1 occurs (normal or
!pedestal event) 

!NOTE: lp4%event_length dosen't mean much for LP4 since the PST's are of
!varying length. During MERGEing of the data lp4%event_length will be given the
!length of each event as it is processed.
!Start program
	m=9				!First address with bit 4 (10 octal) on
					!Needed for all addresses in jmp table
	lp4%inst(trigger1)=jmp(m)		!Set jump table address.

	lp4%tag_count=lp4%tag_count+1
	lp4%tag(lp4%tag_count)=m  	!Save trigger tag value

	lp4%inst(m)=read_tag		!Get tag address for this list processor
	lp4%slot_used(m)=list_proc_4%slot
	lp4%device(m)="Read LP TAG"
	lp4%event_length=1		!Count it
	m=m+1				!trigger.


!Read event number from MALU
	call gpr10_lp_build_malu(malu4,lp4,m)
!Read GRS2 GPS clock interface.
					!Read and clear grs2 GPS clock.	
	if(grs2%online)then
	     	grs2%start=lp4%event_length+1  !Location in buffer of first 
						!data word of this module
		do i=0,2
			lp4%inst(m)=fna(f2,grs2%slot,i)
			lp4%slot_used(m)=grs2%slot
			lp4%device(m)=grs2%dev_type
			lp4%event_length=lp4%event_length+1
			m=m+1
		enddo
		grs2%end=lp4%event_length 	!Location in buffer of last 
						!data word of this scaler
	endif

!Read out LIVE TIME scaler.	Its here (in crate 4) because we have cascaded
!channel 0 to 1 and channels 2 t0 3 to create 48 bit live_time and elapsed_time
!scalers. Stored as 2 24 bit words
!Read Live_time Scaler (if it is enabled) only first n_live_chan channels
	IF (live_time%online) THEN
	     	live_time%start=lp4%event_length+1 !Location in buffer of first 
						!data word of this scaler
		do i=0,n_live_chan-1
		   lp4%inst(m)=fna(f0,live_time%slot,i)
		   lp4%slot_used(m)=live_time%slot
		   lp4%device(m)=live_time%dev_type
		   lp4%event_length=lp4%event_length+1
		   m=m+1			     
		enddo
		live_time%end=lp4%event_length	!Location in event of last 
						!data word of this scaler
	ENDIF


!LP4:Trigger pattern unit
!Read out trigger pattern unit.
!First a pretag
	do i=1,npst
		if(pst(i)%online)then
			lp4%tag_count=lp4%tag_count+1
			lp4%tag(lp4%tag_count)=m  	!Save pst tag value
			lp4%inst(m)=read_tag		!Get tag address for 
			lp4%device(m)="Read LP TAG"	!this list processor
			lp4%event_length=lp4%event_length+1 	!Count it
			pst(i)%start=lp4%event_length	!Points to pre-tag
			m=m+1				
			exit			!Only do once.
		endif
	enddo
!Now read pst's
!amb: we can either readout the PST in the normal way (ie only read out a 
!module if it fired), or we can disable readout of the PST to keep the data 
!buffer and manipulation to a minimum.
	do i=1,npst
           IF(PST_READ_NORMAL) THEN
		if(pst(i)%online)then
			call gpr10_lp_build_add_jmp(lp4,m)
				!Note that with the q_ignore bit set
				!here if we have no data in this word (no-q) the
				!address pointer won't increment.
			lp4%inst(m)=fna(f2,pst(i)%slot,a0)+q_ignore 
			lp4%slot_used(m)=pst(i)%slot
			lp4%device(m)=pst(i)%dev_type
			lp4%event_length=lp4%event_length+1

			m=m+1  
			lp4%inst(m)=jmpnoq(m+2)	 !Jump end of patch tag read
			lp4%slot_used(m)=pst(i)%slot
			lp4%device(m)=pst(i)%dev_type

			m=m+1 
			lp4%inst(m)=jmp(m-2)

			m=m+1 
			lp4%tag_count=lp4%tag_count+1
			lp4%tag(lp4%tag_count)=m  	!Save pst tag value
			lp4%inst(m)=read_tag		!Get tag address for 
			lp4%device(m)="Read LP TAG"	!this list processor
			lp4%event_length=lp4%event_length+1 	!Count it
			m=m+1				
		endif
            ELSEIF(PST_READ_NONE) THEN
                if(pst(i)%online)then
			lp4%tag_count=lp4%tag_count+1
			lp4%tag(lp4%tag_count)=m  	!Save pst tag value
			lp4%inst(m)=read_tag		!Get tag address for 
			lp4%device(m)="Read LP TAG"	!this list processor
			lp4%event_length=lp4%event_length+1 	!Count it
			m=m+1				
		endif
            ENDIF

	enddo

!we are now done with reading out this crate. Generate the all done flag for
!the program in LP3 which will open event gate when all data for this event
!is read in.

!	lp4%inst(m)=fna(f25,sob4%slot,a1)	!Set all done flag. 
	lp4%inst(m)=fna(f25,sob4%slot,a2)	!Set all done flag. 
	lp4%slot_used(m)=sob4%slot
	lp4%device(m)=sob4%dev_type
						!SOB4-a1-out is connected to
						!SOB3-a4-in
	m=m+1

	
	lp4%inst(m)=jmpawt(0)			!go wait for next event

	
	lp4%last=m				!Save last address for listing
						!generation
!Write out program listing
	open(12,file="LP4_program.lis",status="REPLACE")
	call gpr10_lp_dump(lp4)
	close(12)

!***************************************************************
!CRATE 5	  Scaler crate
!   Note this crate is only read out for pedestal events.
!***************************************************************
!Start LP crate 5 program
!	The lowest 7 (0-6)addresses are a jump table for the various
!	triggers. We only use 1 trigger in LP5. Its probably generated by the
!	1pps signal  
!		Trigger#1 : Normal trigger: 
! 				1:Get tag
!				2:Read evnet number from MALU5
!				3:Readout Scalers
!	We don't have to send back an crate done signal since this will be
!	well done before the next trigger comes. Thus we don't need a
!	SOB unit in this crate.

!	Define a the list processor intruction pointer read command. This
!	This command is used to "tag" the data. It is also used to put in
!	a "place" value in the data stream when a camac module is to be skipped
	read_tag=fna(f1,list_proc_5%slot,a0) 

!Pedestal event readout. Jumped to when lp5 trigger#1 occurs (Pedestal +normal
!event) 

!Start program
	m=9				!First address with bit 4 (10 octal) on
					!Needed for all addresses in jmp table
	lp5%inst(trigger1)=jmp(m)		!Set jump table address.

					!First we need to see if this was a
					!pedestal event or a normal event.
					!Pedestal events are flaged by
					!SOB5-a0-in being set.
	lp5%inst(m)=fna(f27,sob5%slot,a0)+q_ignore	!Test sob5-a0-in
	lp5%slot_used(m)=sob5%slot
	lp5%device(m)=sob5%dev_type
	m=m+1  
	lp5%inst(m)=jmpnoq(m+2)			!Jump to clear malu.(Thats why
	m=m+1					!we do this test.
	lp5%inst(m)=jmp(m+3)
	m=m+1
	lp5%inst(m)=fna(f9,malu5%slot,a0)	!Clear data memory and lam
	lp5%slot_used(m)=malu5%slot
	lp5%device(m)=malu5%dev_type
 
	m=m+1					!request of termination.
	lp5%inst(m)=jmpawt(0)			!Go wait for next event

	m=m+1					!Scaler readout.
	lp5%tag_count=lp5%tag_count+1
	lp5%tag(lp5%tag_count)=m  	!Save trigger tag value

	lp5%inst(m)=read_tag		!Get tag address for this list processor
	lp5%slot_used(m)=list_proc_5%slot
	lp5%device(m)="Read LP TAG"
	lp5%event_length=1		!Count it
	m=m+1				!trigger.


!Read event number from MALU
	call gpr10_lp_build_malu(malu5,lp5,m)

    
!SCALERS
!First Read Lecroy 4434 scalers
!Read  them
	do i=1,n_lecroy_scaler
				!Test is this scaler is to be read out.
		if(lscal(i)%online)then
		     	lscal(i)%start=lp5%event_length+1
						!Location in buffer of first 
						!data word of this module
			do j=1,32
				lp5%inst(m)=fna(f2,lscal(i)%slot,a0)
				lp5%slot_used(m)=lscal(i)%slot
				lp5%device(m)=lscal(i)%dev_type
				lp5%event_length=lp5%event_length+1
				m=m+1
			enddo
			lscal(i)%end=lp5%event_length
					 	!Location in buffer of last 
						!data word of this scaler
		endif
	enddo
!Now Phillips 3420 scalers
!Read  them
	do i=1,n_phillips_scaler
				!Test is this scaler is to be read out.
		if(pscal(i)%online)then
			lp5%inst(m)=fna(f11,pscal(i)%slot,a1)	!Resets bank
			lp5%slot_used(m)=pscal(i)%slot
			lp5%device(m)=pscal(i)%dev_type
			m=m+1
		     	pscal(i)%start=lp5%event_length+1
						!Location in buffer of first 
						!data word of this module
			do j=1,31   !SMB read 32 gives Q=0 and lp error
                                    ! message "no X" so use block read
                                    ! for first 31 channels only
				lp5%inst(m)=fna(f4,pscal(i)%slot,a15) !Qscan
				lp5%slot_used(m)=pscal(i)%slot
				lp5%device(m)=pscal(i)%dev_type
				lp5%event_length=lp5%event_length+1
                                m=m+1
      			enddo
                                lp5%inst(m)=fna(f0,pscal(i)%slot,a15) !a15 in 2nd bank
                                                                      !=> scaler 32 
                                lp5%event_length=lp5%event_length+1
                                m=m+1

			pscal(i)%end=lp5%event_length
					 	!Location in buffer of last 
						!data word of this scaler
			lp5%inst(m)=fna(f11,pscal(i)%slot,a4)	!Resets scalers
			lp5%slot_used(m)=pscal(i)%slot
			lp5%device(m)=pscal(i)%dev_type
			m=m+1
		endif
	enddo
        
!HJR    generate SOB out signal to clear LeCroy scalers  

	lp5%inst(m)=fna(f25,sob5%slot,a2)	! Set all done flag. 
        m = m + 1 
!HJR 

!we are now done with reading out this crate.
	
	lp5%inst(m)=jmpawt(0)			!go wait for next event

	lp5%last=m				!Save last address for listing
						!generation
!Write out program listing
	open(12,file="LP5_program.lis",status="REPLACE")
	call gpr10_lp_dump(lp5)
	close(12)
	return
    END SUBROUTINE GPR10_LP_BUILD
!***************************************************************


    SUBROUTINE GPR10_LP_DUMP(lp)
!	Creates a listing of lp program.
!	This is just a rewrite of the original code into f90. Not very
!	inspiring code.
	use camac_def

	IMPLICIT NONE

	type(lp_data) :: lp

	integer :: i,j
	integer*2:: m,iflag=0,st_br,jmpbit,jmpmask,brmask,nmask
	integer*2 :: amask,fmask
	integer*2 :: jmp_cond,f_8,branch_add,q_ign
	character(len=3) :: n,a,f
	character(len=6):: jmp_code

	jmpbit=2**14				!(40000 octal)
	jmpmask=2**13+2**12+2**11 		!(34000 octal)
	nmask=2**13+2**12+2**11+2**10+2**9 	!(37000 octal)
	brmask=2**11-1				!( 3777 octal)
	amask= 2**8+2**7+2**6+2**5		!(  740 octal)
	fmask=2**5-1				!(   37 octal)

	write(12,1000)
1000	format(" All numbers are in octal",/, &
	&"    m     inst          jmp-cond br-add Q-ig&
	&             Device Slot F  A")

	do i=0,lp%last
		if(lp%inst(i).eq.0)then
			if(iflag.ne.1)	write(12,1004)
1004	format("0")
			iflag=1
		else
	!deconvolve command.
			iflag=0
			jmp_code="      "
			jmp_cond=0
			if(lp%inst(i).lt.0)then
				st_br=1
						!Set stop or branch to 1
			else
				st_br=0
			endif
		if(st_br.ne.0)then
			if(iand(lp%inst(i),jmpbit)/=0)then
					!Jmp command.
				jmp_cond=iand(lp%inst(i),jmpmask)/(2**11)
				if(jmp_cond==0)then
					jmp_code="uncond"
				elseif(jmp_cond==1)then
					jmp_code="jmpnoq"
				elseif(jmp_cond.eq.2)then
					jmp_code="jmpgrt"
				elseif(jmp_cond==3)then
					jmp_code="jmplst"
				elseif(jmp_cond==4)then
					jmp_code="jmpawt"
				elseif(jmp_cond==5)then
					jmp_code="noqawt"
				elseif(jmp_cond==6)then
					jmp_code="jmpeql"
				elseif(jmp_cond==7)then
					jmp_code="spare_"
				endif
				branch_add=iand(lp%inst(i),brmask)
				f_8=iand(branch_add,8)/8
				write(12,1001)i,lp%inst(i), &
	& jmp_code,branch_add,f_8
1001	format(" ",o5,o8,10x,a,o9,i5)
			else
				!stop command.
				write(12,1002)i,lp%inst(i),"Stop!"
1002	format(" ",o5,o8,5x,a)
			endif
		else
				!FNA command.
			q_ign=iand(lp%inst(i),jmpbit)/jmpbit
			j=iand(lp%inst(i),nmask)/(2**9)
			if(j<10)then
				write(N,'("N",i1)'),j
			else
				write(N,'("N",i2)'),j
			endif
			j=iand(lp%inst(i),amask)/2**5
			if(j<10)then
				write(A,'("A",i1)'),j
			else
				write(A,'("A",i2)'),j
			endif
			j=iand(lp%inst(i),fmask)
			if(j<10)then
				write(F,'("F",i1)'),j
			else
				write(F,'("F",i2)'),j
			endif

			write(12,1003)i,lp%inst(i),q_ign,trim(lp%device(i)),&
                                      & n,f,a
1003	format(" ",o5,o8,31x,i3,"  ",a15," ",a3," ",a3," ",a3)
		endif
		endif
	enddo
                                    
	return
    END SUBROUTINE GPR10_LP_DUMP
!***************************************************************

    SUBROUTINE GPR10_INIT_LP_SOB(list_proc,sob)
!Init crates:	Generate Z,C,Turn off inhibit, Disable triggers
	use camac_def

	IMPLICIT NONE
	
	type(camac_module) :: list_proc
	type(camac_module) :: sob
	integer*4 :: i,m_address
	character(len=12),PARAMETER :: SRN="GPR10_LP_SOB"

	if(list_proc%online)then
!Initalize the list processors WRITE memory address's register to 0
!This is where the lp will start writeing data. Be sure to clear all 24 bits.
		m_address=0
		status=fcfsa(f17,list_proc%ext_reg_code(a1),m_address,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
 
!Likewise the Memory READ Data pointer!
		m_address=0
		status=fcfsa(f17,list_proc%ext_reg_code(a2),m_address,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)

!init the instruction pointers to 0 in preperation for lp triggers.
		w_data_i2=0
		status=fcssa(f17,list_proc%ext_reg_code(a0),w_data_i2,q) 
		if(.not.btest(status,0)) call gos_signal(srn,status)
	
!Clear all input channels of the sob's by reading them.
		if(sob%online)then
			do i=0,7
				status=fcssa(f27,sob%ext_reg_code(i), &
			              & w_data_i2,q)
				if(.not.btest(status,0)) &
						& call gos_signal(srn,status)
			enddo
		endif
	endif
	return
    END SUBROUTINE GPR10_INIT_LP_SOB
!*****************************************************************************

    SUBROUTINE GPR10_CRATE_INIT(list_proc,ierr)
!Init crates:	Generate Z,C,Turn off inhibit, Disable triggers
	use camac_def
	IMPLICIT NONE
	
	integer :: jerr
	type(camac_module) :: list_proc
	logical,intent(out) :: ierr
	character(len=16),PARAMETER :: SRN="GPR10_CRATE_INIT"
	character(len=2)  :: crate_id
	character(len=80) :: msg
        integer           :: i 

	ierr=.false.		!Thread will abort if we set ierr to true

	if(list_proc%online)then
				!Don't clear crate 4 if this is a restart.
				!we don't want to clear the livetime scalers.
	    if(.not.(list_proc%crate==4.and.restart_run))then
			!Init crate
        	status=fcccz(list_proc%ext_reg_code(a0))!Generate Z crate. 
						!Also
						!clears any I set by the sob
	        if(status.eq.da_crate_powered_off) then
			write(crate_id,'(i2)')list_proc%crate
	MSG = "Crate #"//crate_id//" is powered OFF! Power it ON and Restart &
	      &Run"
			JERR = GOS_ERROR(SRN,MSG,STATUS) 
!Debug; GHS 14/05/01
		   if(list_proc%crate==2)then
		        msg="Nevermind!Crate 2 is probably really on. Ignore &
			   & until we can fix. GHS 14/05/01"
			JERR = GOS_ERROR(SRN,MSG,STATUS) 
		   else
!enddebug
			IERR = .true.
	       		return
!debug:14/05/01
		   endif
!enddebug
       		endif
        	if(.not.btest(status,0))	then
			call gos_signal(srn,status)
			MSG = "Crate "//crate_id//" failure."
			JERR = GOS_ERROR(SRN,MSG,STATUS) 
      		endif

			!If this crate has a phillips scaler in it we have to
			!wait 300 milli sec before continuing on.
		do i=1,n_phillips_scaler
			if(pscal(i)%crate==list_proc%crate)then
				call gpr10_wait(.4)
				exit
			endif
		enddo

        	status=fcccc(list_proc%ext_reg_code(a0)) !Generate C crate
	        if(.not.btest(status,0)) call gos_signal(srn,status)
            endif
		
!HJR?       status=fccci(list_proc%ext_reg_code(a0),0)        !Turn off Inhibit.
            status=fccci(list_proc%ext_reg_code(a0),.FALSE.)  !Turn off Inhibit.
	    if(.not.btest(status,0)) call gos_signal(srn,status)

!Disable triggers
!	Disable trigger list processor just in case.(Note this is NOT the event
!	gate we are playing with but the internal LP enable.
	    status=fcssa(f24,list_proc%ext_reg_code(a0),w_data_i2,q)
	    if(.not.btest(status,0)) call gos_signal(srn,status)

	endif
	return
    END SUBROUTINE GPR10_CRATE_INIT
!*****************************************************************************

    SUBROUTINE GPR10_CRATE5_RESTART(ierr)
!-------------------------------------------------------------------------------
! 	This routine_ does whats needed to resinitalize and restart crate 5 if
!	it happens to need it during a run. This routine will not interfere
!	with data taking.
!-------------------------------------------------------------------------------
!       This includes:
!	1.Initalize all the camac modulas and crates.
!	2. Clear all input sob channels.
!-------------------------------------------------------------------------------
!	Written by:
!		Glenn Sembroski
!		Physics Dept.
!		Purdue Univ.
!		W.Lafayette, In 47907
!		765-494-5172
!		19/5/99
!	Modified:

!	19/5/99 GHS
!		This is a stripped down version of GPR10_INIT for crate 5 only
!-------------------------------------------------------------------------------

	use camac_def

	IMPLICIT NONE 
	logical,intent(out):: ierr
	

	character(len=15),PARAMETER :: SRN="GPR10_CRATE5_RESTART"
	character(len=80) :: msg
	INTEGER*4 ::  i,j,error
	
	ierr=.false.
!Init crate 5:	Generate Z,C,Turn off inhibit, Disable triggers
	call gpr10_crate_init(list_proc_5,ierr)
	if(ierr)return


!	Test list processor  in  crate 5. Book it.
!	LP don't know who books them but they have to be booked for
!	triggers.
	call gpr10_lp_unbook(list_proc_5,ierr)
	if(ierr)return

!	Load the list processor  programs.
	call gpr10_lp_load(lp5,list_proc_5)

!Note:: GPR10_LP_BUILD writes "listings" of the lp programs to
!	files: LP1_PROGRAM.LIS,LP2_PROGRAM.LIS,LP3_PROGRAM.LIS and
!	LP4_PROGRAM.LIS,LP5_PROGRAM.LIS

!Init lp registers (Memory Read, write and instruction=0, clear all SOB
!	input.
	call gpr10_init_lp_sob(list_proc_5,sob5)
!Malu5	       
	if(list_proc_5%online)then
		status=fcssa(f9,malu5%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

!Init Lecroy 4434 singles scalers. LOad command register with
!FA(first address)=0,RN(Readout number-1)=31,RD(REadout enable)=1
	w_data_i2=31*(2**8)+1*(2**7)
					!Load Scaler command regs
	do i=1,n_lecroy_scaler
		if(lscal(i)%online)then
			status=fcssa(f16,lscal(i)%ext_reg_code(a0),w_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
		endif   
	enddo

!Init Phillips scalers.
 	do i=1,n_phillips_scaler
		if(pscal(i)%online)then
			status=fcfsa(f11,pscal(i)%ext_reg_code(a4),w_data_i4,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
		endif   
	enddo

	!Init index pointers to computer data buffer for start of new run.
	lp5%start=0
	lp5%buf_empty=.true.      !drops any old data during a restart.

!	Enable the lp triggers. At this time the PMT gate is closed
!	and we should be ready to start.
	if(list_proc_5%online)then
		status=fcssa(f26,list_proc_5%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
	endif

!	The list processors are waiting for a trigger
!	In short: Crate 5 is HOT!
	return

    END SUBROUTINE GPR10_CRATE5_RESTART
!*****************************************************************************

    SUBROUTINE GPR10_LP_BUILD_INIT(lp)
	use camac_def
	use lp_commands

	IMPLICIT NONE
	
	integer*2 :: m,m1
	type (lp_data) :: lp

!	Fill in the instruction memory with self jmps. Good 
!	locations will be replaced below by appropriate commands.
	m1=8	!(10 octal)	!Our First free address after the jump table.
				!with bit 4 on
	do m=m1+1,2047		!Only locations with less then 12 bit
				!addresses (m<2048) can jump to themselves.
		lp%inst(m)=jmp(m)		!To catch LP screw ups!!!!
	enddo
!NOTE: This is just an insurance thing. Some large part ot these self jumps
!	will be replaced by the program but the self jumps will be left.
!	Thus is we have a programing or hardware error and the LP tries to
!	execute a location that its supposed to never get to it will just
!	hang there with a infinite loop of jumps to itself.
				
!	Set up original jump table to point at a jmpawt command.
!	To ignore illegal triggers.Note bit 4 must be on for all addrsss in
!	jump table.

	do m=0,6
		lp%inst(m)=jmp(m1)
	enddo

!	Lets just ignore illegal triggers.
!	Do this since some tirgger inputs are not terminated and noise gets
!	through and can cause false triggers. Actually I don't why we get them
!	but they are easy to ignore and that doesn't seem to bother anything.

!debug
!	lp%inst(m1)=jmpawt(0)		
	lp%inst(m1)=jmp(m1)
!end debug		

!	For upper 6 K lets just let them all jump to loc 7 where we will have
!	a self jump.
	m1=7
	lp%inst(m1)=jmp(m1)

	do m=2048,8191
		lp%inst(m)=jmp(m1)		!To catch LP screw ups!!!!
	enddo
!Initalize "slot_used" which indicates at each instruction location which camac
!slot is being used for that instruction. Used for LP hang error printout.

	lp%slot_used=0		!This is a vector load.
	return

    END SUBROUTINE GPR10_LP_BUILD_INIT
!*****************************************************************************


    SUBROUTINE GPR10_LP_UNBOOK(list_proc,ierr)
!RESET lp(unbooks it also)

	use camac_def

        IMPLICIT NONE 

	type(camac_module),intent(in) ::list_proc
	logical,intent(out) ::ierr
	integer :: jerr
	character(len=15),PARAMETER :: SRN="GPR10_LP_UNBOOK"
	character(len=80) :: msg

	integer:: error_count
	character(len=2) :: cstring

	ierr=.false.
	if(list_proc%online)then
	    error_count=0

	    do
		status=fcssa(f25,list_proc%ext_reg_code(a15),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
		status=fcfsa(f27,list_proc%ext_reg_code(a0),w_data_i4,q)
						!Test its available.
		if(.not.btest(status,0)) call gos_signal(srn,status)
		if(q==1)then
			exit		!its fine
		else
							!Internal write to 
			write(cstring,'(i2)')list_proc%crate
						!convert integer to char
      MSG  = "List processor "//cstring//" did not unbook. Try again."
			jERR = Gos_ERROR(SRN,MSG,3) 
			error_count=error_count+1
			if(error_count>5)then
      MSG  = "Check that ecc_1365 is Running($ SHO SYS). If not:($ eccop/load)"
			jERR = Gos_ERROR(SRN,MSG,3) 
	MSG  = "Aborting run"
			jERR = Gos_ERROR(SRN,MSG,3) 
				ierr=.true.
				return
			endif
		endif
	    enddo
	endif
    END SUBROUTINE GPR10_LP_UNBOOK
!*****************************************************************************

    SUBROUTINE GPR10_LP_BUILD_ADC(adc,lp,m,nadc)
!	Read the adc's
	use camac_def
	use lp_commands

        IMPLICIT NONE 
	
	integer,intent(inout) :: m
	integer,intent(in) :: nadc
	type (lp_data) :: lp
	type (camac_module),dimension(:) :: adc
	integer :: i,j


	do i=1,nadc
!	Check we should read this adc
		if(adc(i)%online)then
			call gpr10_lp_build_test_q(adc(i),lp,m,f8,a0)
			adc(i)%start=lp%event_length+1	!Location in buffer of
							!first data word of
							!this ADC
			do j=0,nadc_chan-2
							!Read channel.
				lp%inst(m)=fna(f0,adc(i)%slot,j)
				lp%slot_used(m)=adc(i)%slot
				lp%device(m)=adc(i)%dev_type
							!count data words in lp
				lp%event_length=lp%event_length+1
				m=m+1
			enddo
			j=nadc_chan-1
				!Module clears on last channel
				!read(f2 does that).
			lp%inst(m)=fna(f2,adc(i)%slot,j)	!Read channel.
			lp%slot_used(m)=adc(i)%slot
			lp%device(m)=adc(i)%dev_type
			lp%event_length=lp%event_length+1
			adc(i)%end=lp%event_length 	!Location in buffer of
							!last data word of
							!this ADC
			m=m+1
		endif
	enddo
	return
    END SUBROUTINE GPR10_LP_BUILD_ADC
!*****************************************************************************

    SUBROUTINE GPR10_LP_BUILD_TEST_Q(module,lp,m,f,a)
!	Set up code that loops on FNA command F,A until Q is
!	recieved. This is used for testing LAM's and for testing sob inputs
!	amoung other things
	use camac_def
	use lp_commands

        IMPLICIT NONE 
	
	integer,intent(inout) :: m
	integer, intent(in) :: f,a
	integer :: m1
	type (lp_data) :: lp
	type (camac_module) :: module

!We will loop back to the LP test Q command
!First make sure that the LP test Q is at a LP instruction
!memory addresss that has bit 4 (10 octal) set. If not jump to the next 
!such address. Do this due to funny Hytec "feature" that would incriment
!the write memory address counter each time the jump to that location was
!executed if the bit wasn't set. Very weird bug!
       	call gpr10_lp_build_address_test(lp,m)

	lp%inst(m)=fna(f,module%slot,a) + q_ignore !Ignore q bit set.
	lp%slot_used(m)=module%slot
	lp%device(m)=module%dev_type
	m=m+1				!Test to see if Q was set.

	lp%inst(m)=jmpnoq(m-1)		!Jump back to camac test command.
	lp%slot_used(m)=module%slot
	lp%device(m)=module%dev_type
	m=m+1
	return
    END SUBROUTINE GPR10_LP_BUILD_TEST_Q
!*****************************************************************************

    SUBROUTINE GPR10_LP_BUILD_ADDRESS_TEST(lp,m)
!Make sure that the LP test Q is at a LP instruction
!memory addresss that has bit 4 (10 octal) set. If not jump to the next 
!such address. Do this due to funny Hytec "feature" that would incriment
!the write memory address counter each time the jump to that location was
!executed if the bit wasn't set. Very weird bug!
!See Note#3 in lp_build
	
	use camac_def
	use lp_commands

        IMPLICIT NONE 

	integer,intent(inout) :: m
	integer :: m1
	type (lp_data) :: lp
       	if(iand(m,8).eq.0)then		!so make its address have bit 4 on.
		m1=m+8-iand(m,7)
		lp%inst(m)=jmp(m1)		!jump to "good" lable(bit 4 on)
		m=m1
	endif
	return
    END SUBROUTINE GPR10_LP_BUILD_ADDRESS_TEST
!*****************************************************************************
    SUBROUTINE GPR10_LP_BUILD_ADD_JMP(lp,m)
!Jump the LP to an adress which has as its lowest 4 bits 10 octal. 
!Do this for the case where we are doing test jumps ahead.
!Do this due to funny Hytec "feature"
! that would incriment the write memory address counter each time the jump to
! that location was
!executed if the bit wasn't set. Very weird bug!
!See Note#3 in lp_build
	
	use camac_def
	use lp_commands

        IMPLICIT NONE 

	integer,intent(inout) :: m
	integer :: m1
	integer,parameter :: mask8=2**4-1	!octal 17
	type (lp_data) :: lp
       	if(iand(m,mask8)/=8)then  	!so make its address have lowest for
					!bits be octal 10.
		if(iand(m,8)==0)then
			m1=m+8-iand(m,7)
					else
			m1=m+16-iand(m,7)
		endif
		lp%inst(m)=jmp(m1)		!jump to "good" lable
		m=m1
	endif
	return
    END SUBROUTINE GPR10_LP_BUILD_ADD_JMP
!*****************************************************************************

    SUBROUTINE GPR10_LP_BUILD_MALU(malu,lp,m)
!	Read an event number form a malu
	
	use camac_def
	use lp_commands

        IMPLICIT NONE 

	integer,intent(inout) :: m
	type (lp_data) :: lp
	type (camac_module) :: malu

!     This doesn't work if the event modules don;'t work so they
!	WILL always be there!

!SJF ********************* BEGIN SJF ADDED SECTION ***************************
!       ADDED TO SEE IF WEIRD MISMATCHED EVENT PROBLEMS GO AWAY
        call gpr_lp_build_test_q(malu,lp,m,f8,a0)
!SJF ********************** END SJF ADDED SECTION ****************************

	lp%inst(m)=fna(f2,malu%slot,a0) 	!Read lower 16 bits
	lp%event_length=lp%event_length+1	!count data words in lp
	lp%slot_used(m)=malu%slot
	lp%device(m)= malu%dev_type
	malu%start=lp%event_length		!Location in buffer of
						!first malu data word.
	m=m+1

	lp%inst(m)=fna(f2,malu%slot,a1)		!Read upper 16 bits and
	lp%event_length=lp%event_length+1	!count data words in lp
	lp%slot_used(m)=malu%slot
	lp%device(m)= malu%dev_type
	malu%end=lp%event_length		!Location in buffer of
	m=m+1					!clear all
	return

    END SUBROUTINE GPR10_LP_BUILD_MALU
!*****************************************************************************
    
    SUBROUTINE GPR10_OPEN_GATE
        ! open the event gate. THis starts the data taking.
	use camac_def

        IMPLICIT NONE 
	character(len=15),PARAMETER :: SRN="GPR10_OPEN_GATE"

!	Send a pulse through sob3-a1-out which opens the event gate.
	status=fcssa(f25,sob3%ext_reg_code(a1),w_data_i2,q)
	if(.not.btest(status,0)) call gos_signal(srn,status)
	return
    END SUBROUTINE GPR10_OPEN_GATE
!*****************************************************************************
    
    SUBROUTINE GPR10_N2_ON
! Turn on N2 Pulser.
	use camac_def

        IMPLICIT NONE 
	character(len=15),PARAMETER :: SRN="GPR10_N2_ON"
!	Send a pulse through sob3-a2-out 
	status=fcssa(f25,sob1%ext_reg_code(a2),w_data_i2,q)
	if(.not.btest(status,0)) call gos_signal(srn,status)
	return
    END SUBROUTINE GPR10_N2_ON
!*****************************************************************************

    SUBROUTINE GPR10_N2_OFF
! Turn off N2 Pulser.
	use camac_def

        IMPLICIT NONE 
	character(len=15),PARAMETER :: SRN="GPR10_N2_OFF"
!	Send a pulse through sob3-a3-out 
	status=fcssa(f25,sob1%ext_reg_code(a3),w_data_i2,q)
	if(.not.btest(status,0)) call gos_signal(srn,status)
	return
    END SUBROUTINE GPR10_N2_OFF
!*****************************************************************************

    SUBROUTINE GPR10_PEDESTAL_GEN
! Generate pedestal trigger.
	use camac_def

        IMPLICIT NONE 
	character(len=20),PARAMETER :: SRN="GPR10_PEDESTAL_GEN"
!	Send a pulse through sob3-a4-out
	status=fcssa(f25,sob1%ext_reg_code(a4),w_data_i2,q)
	if(.not.btest(status,0)) call gos_signal(srn,status)
	return
    END SUBROUTINE GPR10_PEDESTAL_GEN
!*****************************************************************************
    
    SUBROUTINE GPR10_REQUEST_PAUSE
        ! Request the at the end of the next event that LP3 leave the event
	! gate closed which basically stops data acquisition.
	! Put some handshaking in here from the LP to insure
	! it got the request and satisfied it.
	use camac_def

        IMPLICIT NONE 
	integer :: i
	character(len=25),PARAMETER :: SRN="GPR10_REQUEST_PAUSE"

!	Send a pulse through sob3-a3-out which goes to sob3-a0-in which LP3
!	looks at to see if it should reopen the event gate after an event.

	status=fcssa(f25,sob3%ext_reg_code(a3),w_data_i2,q)
	if(.not.btest(status,0)) call gos_signal(srn,status)

!Now wait for a handshake back from the LP on sob3-a6-in(comes from
!sob3-a6-out)
	do i=1,10
 		status=fcssa(f27,sob3%ext_reg_code(a6),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
		if(q==1) exit
		call gpr10_wait(.1)
	enddo
	if(q/=1)then
		print*,"Receipt of end of run request not confirmed by LP3!"
	endif
	return
    END SUBROUTINE GPR10_REQUEST_PAUSE
!*****************************************************************************

    SUBROUTINE GPR10_READ_CAMAC(got_data)
!-------------------------------------------------------------------------------
!This is the routine_ that gets activated as needed to read out the event
!data.  
!	Written by:
!		Glenn Sembroski
!		Physics Dept.
!		Purdue Univ.
!		W.Lafayette, In 47907
!		765-494-5172
!		07/8/97
!-------------------------------------------------------------------------------
!	Modified:


!***************************************************************************
!	TUTORIAL ON List Processor MEMORY and HOW WE UTILIZE IT.

!	1:The list processor data memories are 256 K words long. The memory in
!       each LP is addressed by two independent 24 bit registers of which only
!	  the lower 18 bits in each are used.  The registers are called the
!	  READ Memory Address Register and the Write Memory Address Register.
!	  When the LP reads data from CAMAC it writes the data it gets into the 
!	  LP data Memory using the READ memory Address register in an Auto 
!	Incriment (after command)Mode. The WRITE Memory Address register is 
!	used as a pointer(also in an auto incriment manner) when data is 
!	written to camac by the LP, or by our choice read out be the computer.
!	 The Memory Address Registers wrap around to 0 when 
!	  they get to all 18 bits full. The top 6 bits are unused and should be 
!	  masked out.

!	2:Our scheme requires that the computer be able to read previously 
!	  collected events from the LP's as new events are being collected by
!	   the LP programs in a fully asyncronous manner. We do this by:
!	   a:The LP Read address registers are fully dedicated to the use by 
!	     the programs in the LP's only(however they may be read by the 
!	     computer, just never modified.)
!	   b:The computer uses the LP WRITE address registers to read out the 
!		LP memories.
!	3:In detail then:
!	  a:The event acquisition programs in the list processors(see 
!	    GPR10_LP_BUILD) acculumates event data as triggers(all lp use only
!	    trigger #1) occur. There are at present 2 types of events. They are
!	flaged by bits set in the trigger unit in crate3. The
!	    first is a normal triggerd event where crates lp1,lp3,lp4 are read
!	    out. We also have an PEDESTAL event which triggers all crates
!           (thus getting pedestal information from the adc's) including crate
!           5 which has the ENVIRONMENTAL specific data(like scalers).
!	Triggers can only be generated if the EVENT GATE is enabled. Upon
!	reciept of a trigger the event gate is closed by the trigger logic.
!	    When crates lp1 and lp4 are finished reading out their event data
!	    they communicate this through signals from the sob's to the program
!           running in LP3(We don't need to wait for crate 5 since its triggers
!	    alwyas come far apart in time. The program in lp3 then tests the 
!	TERMINATE REQUEST flag  bit sob3-a0-in which can be set by the computer
!	when it wants to stop data acquisition. If this flag is not found LP3
!	then opens the EventGate (trough sob3-a1-out) and we are then ready for
!	the next trigger. If we are to terminate data taking the LP3 
!	program sets sob3-A6-out which is tied to input bit sob3-A6-in. This 
!	flag indicates to the computer the that Termination Request was
!	accepted. The LP program then readys itself for the next event but 
!	DOES NOT! open the event gate. Thus triggers can not be accepted until
!	the computer itself opens the event gate(used for nitrogen runs).

!	The Computer determines when data from all LP memopries should be 
!	readout by waiting for a time determined from the measured event rate
!	and the known event size in LP1(which has nominally the most data per 
!	event) such that the amount of data transfered will be large(approx
!	4000 words or more).
!	The choice of the size of buffers to read out is driven by the
!	efficiency of transfer from the lP to the computer. The highest data 
!	rate possible is obtained when the size of the buffers is above 4000 
!	words.
!	When it is time to readout data this routine is called and it reads the
!	value of the LP Read Address registers to indicate where LPs last wrote
!	out data. Pointers are kept which are the starting address of new data 
!	in the lp data memorys, (first word after the end of the last 
!	data buffer read out). Thus the amount of new data in each lp can be 
!	determined.
!	The main goal in all this is to obtain the highest possible maximum
!	event rate. The data taking is disabled only by the lp themseleves and
!	then for extrealy short times. The LP's run indepenmdently of the
! 	computer. If the computer dies the lp will happily keep on running 
!	taking data. Its up to the computer to keep up with the LP to prevent 
!	overwriting of the data.


!	One thing this routine tries to do is to attempt recovery from time 
!	gaps due to open pmt gate failure.
!		Insted of automatic resetting of the LP's(which looses events,
!	screws	up livetime, etc) when a time gap is idientified(by noticing
!	that no new data has been read by the LP's in a time of MAX_GAP, we 
!	look to see if all LP's are waiting for a trigger. This may mean that 
!	event gate didn't open when it was supposed to. If so the computer
!	sends a pulse through sob3-a1-out to enable PMT triggers, we then
!	wait a second and see if lp memory pointer address have changed. If not
!	we are truly stuck and need LP reset.

!-------------------------------------------------------------------------------
!       Start of lp processing:
!-------------------------------------------------------------------------------
	use camac_def

        IMPLICIT NONE 

	logical,intent(out) :: got_data
	logical :: ierr
	logical :: restart
	integer :: number_to_do
	real*8 utc,utc_old,elapsed_time
	character(len=10) :: gap_max	
	character(len=80) :: msg
	integer :: jerr
        character(len=16),PARAMETER :: SRN="GPR10_READ_CAMAC"

!	At this point data taking is in progress and the ECC is no longer
!	busy. 
        IERR = .false.          ! reset error flag 

!We've put lots of checks in here to watch for hardware screw ups.

!	Determine if any data has been acquired by lp3 since the end of the
!	last processed buffer.
!	Use lp3 because it should always exits even in any funny test modes.
	call gpr10_get_read_add(lp3,list_proc_3)

!Do we have any data to readin.
     	CALL GOS_UTC(UTC)                           ! get UTC time 
	elapsed_time=utc-utc_old

!Hardware check:Test that we are not hung up.
	if(lp3%length==0.and.(.not.gpr10_ctrl%exit))then

!		Attempt recovery from time gaps due to pmt gate failure.
!		Insted of automatic flushing of data and reintializing of LP's,
!		when a time gap is idientified look to see 
!		if LP's are waiting for a trigger. This may mean pmt event
!		veto didn't clear when it was supposed to. Send a pulse through
!		sob4-a(1)-out to enable PMT triggers, wait a second and see if
!		lp memory pointer address have changed. If not we are truly
!		stuck and need to do a reset.
gap_test:	if(elapsed_time>gpr10_ctrl%MAX_GAP)then	
                	
						!We waited MAX_GAP seconds. Too
						!long. Get instruction pointers
						!to see if trigger is stalled.
			write(gap_max,'(f8.1)') &
			& gpr10_ctrl%max_gap*seconds_in_day
			msg="Time Gap of over "//gap_max//" seconds found."
	       		jerr = Gos_ERROR(SRN,MSG,4) 
			restart=.false.

!Test for bad status in lp's and for lps in infinite loops due to no q response
!durin either LAM tests for module ready or waiting for handshake. If not
!either(all lp address at 0) assume closed event gate.
			call gpr10_lp_test(lp1,list_proc_1,restart) !lp1
			call gpr10_lp_test(lp2,list_proc_2,restart) !lp2
			call gpr10_lp_test(lp3,list_proc_3,restart) !lp3
			call gpr10_lp_test(lp4,list_proc_4,restart) !lp4
			call gpr10_lp_test(lp5,list_proc_5,restart) !lp5

start_over:		if(restart)then
					!Set the restart flag. This
					!causes the restart run routine
					!to be invoked from
					!GPR10_START
		print*,' lp_test error in read_camac'
				restart_run=.true.
				return
			else

! Attempt to resume data acquisition. All LP at 0 awaiting trigger. Probably
! we have a closed event gate.
				msg="Attempt to resume data acquisition."
		       		jerr = Gos_ERROR(SRN,MSG,4) 

!Open event gate
!Debug loop here:GHS 8/2/99 Remove when problem fixed!
!Debug. Problem fixed I think! It was a bad LP(I think).
!debug			do						!debug

	 			CALL GPR10_OPEN_GATE  !open gate. This restarts
						      !the run.
				CALL gpr10_wait(1.0)! Go to sleep for a bit.
						!check for change in address 
						!pointers.
				call gpr10_get_read_add(lp3,list_proc_3)

!debug			print*,' lp3%length,lp3%read_add,lp3%start:',&
!debug				&lp3%length,lp3%read_add,lp3%start
!debug				if(lp3%length/=0)then		        !debug
!debug					exit                            !debug
!debug				endif                                   !debug
!debug			enddo                                           !debug


!See if we've got any now. 
				if(lp3%length==0)then		
						!Didn't work. reset!
					msg="Recovery Failed!"
			       		jerr = Gos_ERROR(SRN,MSG,4) 
						!Set the restart flage. This
						!causes thr restart run routine
						!to be invoked from
						!GPR10_START
					restart_run=.true.
					return
				else
					msg="Recovery Succeded!"
			       		jerr = Gos_ERROR(SRN,MSG,4) 
							!Reset timer.
					utc_old=utc
					got_data=.false.!No data or we wouldn't
							!have gotten here
					return
				endif
			endif start_over
		endif gap_test
		got_data=.false.!No data or we wouldn't have gotten here
		return
       endif

!Data Acqusition time. We have data.
!Read in all. This call assumes for speed reasons that we already have the
!lp3%read_add.

	call gpr10_get_data(ierr)
	if(ierr)then				!Added 17/2/98 GHS.
		gpr10_ctrl%quit=.true.
		return
	endif
	if(gpr10_ctrl%exit)return		
	got_data=.true.

	utc_old=utc
	return
    END SUBROUTINE GPR10_READ_CAMAC
!*****************************************************************************

    SUBROUTINE GPR10_ERROR_REPORT(lp,list_proc,rdata)
!	Report on what device in what slot in what crate caused LP to stop.
	use camac_def

        IMPLICIT NONE 

	type(camac_module) :: list_proc
	type(lp_data) :: lp
 	integer*4,intent(in)::rdata
	integer :: jerr
	character(len=21) :: srn="GPR10_ERROR_REPORT"
	character(len=2) :: crate_id,slot_id	
	character(len=80) :: msg
	character(len=10) :: r


	write(slot_id,'(i2)')lp%slot_used(rdata)
	write(crate_id,'(i2)')list_proc%crate
	write(r,'(i10)')rdata

	msg="Crate #"//crate_id//" List Processor stopped at program &
	    & location "//r
        jerr = Gos_ERROR(SRN,MSG,1) 
	if(lp%slot_used(rdata)/=0)then
	msg=trim(lp%device(rdata))//" module in slot "//slot_id//" caused LP&
            &  stop."
	        jerr = Gos_ERROR(SRN,MSG,1) 
	endif
	return
    END SUBROUTINE GPR10_ERROR_REPORT
!*****************************************************************************

    SUBROUTINE GPR10_LP_TEST(lp,list_proc,restart)
!Test reason for time gap:
! 1:bad status hung LP
! 2:No q back from test q(lam test or handshake)
! 3:If not either of above calling routine will assume  Closed event gate.
	use camac_def

        IMPLICIT NONE 

	type(lp_data) :: lp
	type(camac_module) :: list_proc
	logical,intent(inout) :: restart
	integer :: jerr

	character(len=13) :: srn="GPR10_LP_TEST"
	character(len=2) :: crate_id	
	character(len=80) :: msg

	if(list_proc%online)then
!NOTE:  restart can only be set true by this routine, Previous calls
!	to this routine for this time gap for other lp's may have already done
!	that. Thus we don't ever want to set it to false within this routine.

!Get present address of program
		status=fcssa(f1,list_proc%ext_reg_code(a0),lp%inst_reg,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
		lp%inst_reg=iand(lp%inst_reg,instruction_mask)

!Get status register
		status=fcssa(f1,list_proc%ext_reg_code(a12),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)
		w_data_i2=iand(w_data_i2,7)	!Only bottom 3 bits of interest

!Check status
		if(w_data_i2.ne.0)then	!Non-zero means we have a problem.
			restart=.true.	!We must reinitalize and start all over.
						!Get instruction pointer.
			status=fcssa(f1,list_proc%ext_reg_code(a0),r_data_i2,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)

			call gpr10_error_report(lp,list_proc,lp%inst_reg)
			write(crate_id,'(i2)')list_proc%crate
			if(btest(w_data_i2,0))then
				msg="List Processor in Crate "//crate_id//&
			            &" stopped due to NO-X recieved from Camac&
				    &  Module"
			        jerr = Gos_ERROR(SRN,MSG,1) 
				msg="Possible Cause:Module may be bad or LP&
				    & read empty slot."
			        jerr = Gos_ERROR(SRN,MSG,1) 
				msg="Fix:Replace/Repair  Module or Set Slot& 
				    & offline."
			        jerr = Gos_ERROR(SRN,MSG,1) 
			endif
			if(btest(w_data_i2,1).and.btest(w_data_i2,2))then
			msg="List Processor in Crate "//crate_id//" stopped &
				    &set both NO-Q and Finish bit"
			        jerr = Gos_ERROR(SRN,MSG,3) 
			msg="Cause:Instruction or memory pointers overflowed or&
				    &STOP/VETO line activated."
			        jerr = Gos_ERROR(SRN,MSG,3) 
			msg="Fix:LP should be configured to not overflow, the&
				    & STOP/VETO line should not be in use."
			        jerr = Gos_ERROR(SRN,MSG,3) 
			elseif(btest(w_data_i2,1))then
		           msg="List Processor in Crate "//crate_id//" stopped &
			    &due to NO-Q recieved from Camac Module"
			        jerr = Gos_ERROR(SRN,MSG,2) 
			msg="Possible Cause:Module is bad or No Gate Received"
	       		        jerr = Gos_ERROR(SRN,MSG,2) 
			msg="Fix:Replace/Repair  Module or Set Slot offline or&
			    & repair gate signal."
			        jerr = Gos_ERROR(SRN,MSG,2) 
			elseif(btest(w_data_i2,2))then
			msg="List Processor in Crate "//crate_id//" stopped &
				    &with FINISH bit set"
			        jerr = Gos_ERROR(SRN,MSG,3) 
			msg="Possible Cause:LP executed a STOP instruction"
			        jerr = Gos_ERROR(SRN,MSG,2) 
			msg="Fix:LP should never execute such instruction. Fix&
				    & LP code."
			        jerr = Gos_ERROR(SRN,MSG,3) 
			endif

!See if hung on a camac module in a loop of some type.
		elseif(lp%inst_reg/=0)then
			call gpr10_error_report(lp,list_proc,lp%inst_reg)
			msg="Cause:No gate received,No handshake Received &
		    & (possible problem in other crate) or Bad camac Module."
		        jerr = Gos_ERROR(SRN,MSG,5) 
			msg="Fix:Replace/Repair  Module or Set Slot offline or &
			    & repair gate signal or fix handshake logic."
		        jerr=gos_ERROR(SRN,MSG,5) 
			restart=.true.
		endif
	endif
return
    END SUBROUTINE GPR10_LP_TEST
!*****************************************************************************

    SUBROUTINE GPR10_GET_READ_ADD(lp,list_proc)
!	Get the value of the read memory address pointer for LP.
! Put result in lp%read_add
!Then determine how much new data we have.
	use camac_def

        IMPLICIT NONE 

	type(lp_data) :: lp
	type(camac_module) :: list_proc
	character(len=22),PARAMETER :: SRN="GPR10_GET_READ_ADDRESS"
	INTEGER*4 :: TEMP
	character(len=15) :: temp_st
	integer :: jerr
	character(len=80) :: msg

	if(list_proc%online)then
				!read register
		status=fcfsa(f1,list_proc%ext_reg_code(a2),lp%read_add,q)
								!24 bit read
		if(.not.btest(status,0)) call gos_signal(srn,status)
			!lp%read_add now has present value of lp read memory 
			!address reg.
!		if(list_proc%crate==5)then
!			temp=lp%read_add
!			write(temp_st,'(i10)')temp
!			msg="lp_read_add raw:"//temp_st
!		        jerr=gos_ERROR(SRN,MSG,5) 
!		endif

		lp%read_add=iand(lp%read_add,mem_mask)

			!Determine size of data read in since last buffer 
			!readout.
		lp%length=lp%read_add-lp%start
			!lp%START is the address in lp data memory where the 
			!we left off reading the last buffer( its the address 
			!of the  first work in the next buffer)
		if(lp%length<0)then
				!Wrap around
			lp%length=lp%length+2**18
		endif
!debug
		if(lp%length<0)then
			print*,' lp%length,lp%read_add,lp%start:',&
				&lp%length,lp%read_add,lp%start
		endif
!enddebug
	endif
	return
    END SUBROUTINE GPR10_GET_READ_ADD
!*****************************************************************************

    SUBROUTINE GPR10_RESTART
!	Things are so screwed up all we can do is restart from scratch as if 
! 	starting a new run.
	use camac_def
	implicit none

	integer :: jerr
	character(len=14),PARAMETER :: SRN="GPR10_RESTART"
	character(len=80) :: msg
	logical ierr

	msg="RESTART in progress:LP's will be&
	     & reinitialized and all buffers flushed."
	jerr=gos_ERROR(SRN,MSG,4) 
	msg="RECOMENDATION: Observer STOP run and fix problem."
	jerr=gos_ERROR(SRN,MSG,4) 

	restart_run=.true.	!Setting this flag prevents GPR10_INIT from
				!clearing livetime/elapsed time scalers and 
				!resetting the event number.
	call gpr10_init(ierr)
	if(ierr)then
		gpr10_ctrl%quit=.true.
		return
	endif

	CALL GPR10_OPEN_GATE  !open gate. This restarts the run.
	return
    END SUBROUTINE GPR10_RESTART
!***************************************************************************

    SUBROUTINE GPR10_GET_DATA(IERR)
!Read out the lp buffers. Do this by using the dynamic allocation command.
!We already have lp3%read_add. Get the others and read out all data up to
!that point. Before we do the read though we need to move the leftover data
!from the previous call to this routine(incomplete events that weren't
!processed) to the bottom of our new buffers. Remember to deallocate when we
!can

	use camac_def

        IMPLICIT NONE 
	
	logical,intent(out) :: ierr
	integer :: error
	integer :: jerr
	character(len=14),PARAMETER :: SRN="GPR10_GET_DATA"
	character(len=80) :: msg

	ierr=.false.
!Data from LP4 is 24 bits!
!all opthers are 16 bits

!Read in the other addresses(we already have lp3 and this read is a major
!source of overhead so don't redo anything we don't have to!
	call gpr10_get_read_add(lp1,list_proc_1)
	call gpr10_get_read_add(lp2,list_proc_2)
	call gpr10_get_read_add(lp4,list_proc_4)
	call gpr10_get_read_add(lp5,list_proc_5)

!We use allocated buffers to hold our data. We keep at any one time an
!old one and a new one. Determine which index is the new one.
!Originally lp_buf_new will be 0
!Toggle
	lp_buf_old=lp_buf_new
	if(lp_buf_new/=1)then
		lp_buf_new=1
	else
		lp_buf_new=2
	endif

	
!Transfer previous data and read new buffers:
	call gpr10_get_i2_buffer(lp1,list_proc_1,buf1,ierr)	!16 bit reads
	if(ierr)return
	call gpr10_get_i2_buffer(lp2,list_proc_2,buf2,ierr)	!16 bit reads
	if(ierr)return
	call gpr10_get_i2_buffer(lp3,list_proc_3,buf3,ierr)     !16 bit reads
	if(ierr)return
	call gpr10_get_i4_buffer(lp4,list_proc_4,buf4,ierr)     !24 bit reads
	if(ierr)return
!NOTE: There is a tricky(SUBTLE) effect here: The scaler LP5 buffer is read out
!	last.This means that if a Pedestal event was put into the LP3 buffer it
!	certainly got into the LP5 buffer. The reverse may not be true. It
!	is perfectly possible that a Pedestal event occured after the readout
!	of LP3 but before the readout of LP5.
!
!	It is also possible that LP5%length is 0(no data).even though the
!	lp1,lp2,lp3,lp4 buffers have data. This is handled as appropriate.

	call gpr10_get_i2_buffer(lp5,list_proc_5,buf5,ierr)     !16 bit reads
	if(ierr)return

	return
    END SUBROUTINE GPR10_GET_DATA
!***************************************************************************

    SUBROUTINE GPR10_GET_I2_BUFFER(lp,list_proc,buf,ierr)
!This is the version for reading 16 bit from the crates
!Determine size of new buffer, allocate it.
!Transfer any leftover data from old buffer to new buffer,
!Deallocate old buffer.
!Read in new data to new buffer from lp
!NOTE: Any place in this routine where we have errors that require a RESTART
! we can't since this is a routine that RESTART calls. So we just have to 
!quit!

!	It is also possible that LP5%length is 0(no data).even though the
!	lp1,lp3,lp4 buffers have data. This is handled as appropriate.
	use camac_def

        IMPLICIT NONE 

	type(lp_data) :: lp
	type(camac_module) :: list_proc

	type(i2_data_pointer),dimension(2) :: buf

	logical,intent(out):: ierr
	integer :: old_size,new_size,i
	integer*2,dimension(:),pointer :: old_ptr,new_ptr,lp_ptr
	integer :: jerr
	character(len=19),PARAMETER :: SRN="GPR10_GET_I2_BUFFER"
	character(len=80) :: msg
        integer :: error,iflag
	integer :: num_to_get,num_so_far
	integer*4 :: start
	integer*4 :: os,ns

! Determine how big our data buffers should be. We need to use the data leftover
! in our previous buffers and all the new stuff.

!Length of old data
   if(list_proc%online)then
	if(lp_buf_old/=0)then
		if(lp%buf_empty)then
		    old_size=0
		else
		    old_size=lp%buf_size(lp_buf_old)-lp%buf_add(lp_buf_old)+1
		endif
	else
		old_size=0
	endif

!Length on new buffer. If 0(possible for crate 5) make it 1
       	lp%buf_size(lp_buf_new)=old_size+lp%length
	if(lp%buf_size(lp_buf_new)>0)then
		new_size=lp%buf_size(lp_buf_new)
	else
		new_size=1
	endif


! check that NEW_SIZE is ok (HJR, 11-NOV-98)
	IF (NEW_SIZE.GT.256*1024) THEN                       ! > 1Mbyte? 
!debug
		write(25,4300)lp_buf_old,lp_buf_new, &
		& lp%buf_size(lp_buf_old),lp%buf_add(lp_buf_old),&
		& old_size,lp%length,new_size
4300	format(' VERY large BUFFer ERROR:',/,' lp_buf_old:',i10, &
		& ' lp_buf_new:',i10,/,' lp%buf_size(lp_buf_old):',i10, &
		& 'lp%buf_add(lp_buf_old):',i10,/,' old_size:',i10, &
		& 'lp%length:',i10,'new_size:',i10)
!Enddebug

!          MSG  = "VERY large buffer size. Aborting run!"      
          MSG  = "VERY large buffer size. Continuing run!"      
	  JERR = GOS_ERROR(SRN,MSG,error) 
!	  gpr10_ctrl%quit = .true.
!	  ierr = .true.	                                       !abort run
!	  return
	ELSE IF (NEW_SIZE.LT.1) THEN                           ! zero or negative?
          MSG  = "Zero or negative buffer size. Aborting run!"      
	  JERR = GOS_ERROR(SRN,MSG,error) 
	  gpr10_ctrl%quit = .true.
	  ierr = .true.					       !abort run
	  return
        ENDIF 

!Allocate new buffer
	allocate(buf(lp_buf_new)%ptr(new_size),stat=error)
	if(error/= 0)then
		msg="Program could not alloctae space for lp buffers."
		JERR=GOS_ERROR(SRN,MSG,error) 
		msg="Aborting Run!"
		JERR=GOS_ERROR(SRN,MSG,31) 
		gpr10_ctrl%quit=.true.
		ierr=.true.		!abort run
		return
	endif

!transfer over old data
	if(old_size/=0)then
		old_ptr=>buf(lp_buf_old)%ptr(lp%buf_add(lp_buf_old):)
		new_ptr=>buf(lp_buf_new)%ptr(1:old_size)

!Debug
!		os=size(old_ptr)
!		ns=size(new_ptr)
!		if(new_size>50000.or.old_size<0.or.os/=ns)then
!		print*,' new_size,crate:',new_size,list_proc%crate
!		msg="new size>50000"
!		JERR=GOS_ERROR(SRN,MSG,32) 
!		endif
!Enddebug
!copy it over
		do i=1,old_size
			new_ptr(i)=old_ptr(i)
		enddo
!re-define to remainder of buffer
		new_ptr=>buf(lp_buf_new)%ptr(old_size+1:)
	else
		new_ptr=>buf(lp_buf_new)%ptr
	endif
!Were done with the old buffer. Deallocate it.
	if(lp_buf_old/=0)then
		deallocate(buf(lp_buf_old)%ptr)
	endif
!Now read in the new data

	start=lp%start
	num_so_far=0
	do
		num_to_get=lp%length-num_so_far
		if(num_to_get>50000)then
			num_to_get=50000
			if(iflag/=1)then
!				msg="DEBUG:OVER 50000 LP read attempted"
!				JERR=GOS_ERROR(SRN,MSG,31) 
				iflag=1
			endif
		endif
				!Point to where this block goes.
		lp_ptr=>new_ptr(num_so_far+1:)
				!and get the block
		call gpr10_read_i2_buffer(list_proc,lp_ptr,num_to_get,&
			     &start,ierr)
		if(ierr)return
						!Get here if it worked. 
		num_so_far=num_so_far+num_to_get
						!See if done.
		if(lp%length==num_so_far)then
			exit
		endif
						!New raed address value for
						!multiple reads.
		start=lp%start+num_so_far
		start=iand(start,mem_mask)	!Clean off top bits. Probably
						!not needed
	enddo


!SEt new start address.
		lp%start=lp%start+lp%length
		lp%start=iand(lp%start,mem_mask)
      endif
    END SUBROUTINE GPR10_GET_I2_BUFFER
!***************************************************************************

    SUBROUTINE GPR10_GET_I4_BUFFER(lp,list_proc,buf,ierr)
!This is the version for reading 24 bit from the crates
!Determine size of new buffer, allocate it.
!Transfer any leftover data from old buffer to new buffer,
!Deallocate old buffer.
!Read in new data to new buffer from lp
!NOTE: Any place in this routine where we have errors that require a RESTART
! we can't since this is a routine that RESTART calls. So we just have to 
!quit!

!	It is also possible that LP5%length is 0(no data).even though the
!	lp1,lp3,lp4 buffers have data. This is handled as appropriate.

	use camac_def

        IMPLICIT NONE 

	type(lp_data),        intent(out,in)  :: lp
	type(camac_module),   intent(in)      :: list_proc
	type(i4_data_pointer),intent(out)     :: buf(2)
	logical, intent(out)                  :: ierr

	integer*4,dimension(4) :: cb
	integer :: old_size,resub,sizeg
	integer*4,dimension(:),pointer :: old_ptr,new_ptr
	character(len=9) :: osize,nsize
	character(len=2) :: crate_id
	integer :: jerr
	character(len=19),PARAMETER :: SRN="GPR10_GET_I4_BUFFER"
	character(len=80) :: msg
        integer :: error

!HJR 
        integer, parameter :: n19 = 2**19         ! max length of LP memory?
        integer*4          :: temp(1:n19) 
        integer            :: nw = 0              ! allocated memory
!HJR 

! Determine how big our data buffers should be. We need to use the data leftover
! in our previous buffers and all the new stuff.

!Length of old data
   if(list_proc%online)then
	if(lp_buf_old/=0)then
		if(lp%buf_empty)then
		    old_size=0
		else
		    old_size=lp%buf_size(lp_buf_old)-lp%buf_add(lp_buf_old)+1
		endif
	else
		old_size=0
	endif


!Length on new buffer. If 0(possible for crate 5) make it 1
       	lp%buf_size(lp_buf_new)=old_size+lp%length
	if(lp%buf_size(lp_buf_new)>0)then
		sizeg=lp%buf_size(lp_buf_new)
	else
		sizeg=1
	endif

!*****************************************************************************
!*** is the access violation crash due to a perpetually increasing
!*** buffer requirement?

! check that sizeg is ok (HJR+SMB, 11-Jan-99)
	IF (sizeg.GT.25000) THEN                       ! > 0.1 MBytes? 
                                                       ! (60s x 40Hz x ~10 words) 
		write(25,4400)lp_buf_old,lp_buf_new, &
		& lp%buf_size(lp_buf_old),lp%buf_add(lp_buf_old),&
		& old_size,lp%length,sizeg
4400	format(' VERY large BUFFER ERROR:',/,' lp_buf_old:',i10, &
		& ' lp_buf_new:',i10,/,' lp%buf_size(lp_buf_old):',i10, &
		& 'lp%buf_add(lp_buf_old):',i10,/,' old_size:',i10, &
		& 'lp%length:',i10,'new_size:',i10)
    
          MSG  = "VERY large buffer size. Continuing run!"      
	  JERR = GOS_ERROR(SRN,MSG,error) 

        ENDIF
!*****************************************************************************


!Allocate new buffer
	allocate(buf(lp_buf_new)%ptr(sizeg),stat=error)
	if(error/= 0)then
		msg="Program could not alloctae space for lp buffers."
		JERR=GOS_ERROR(SRN,MSG,error) 
		msg="Aborting Run!"
		JERR=GOS_ERROR(SRN,MSG,31) 
		gpr10_ctrl%quit=.true.
		ierr=.true.		!abort run
		return
	else 
          nw = nw + sizeg 
	endif

!HJR 
        if (nw.gt.2*n19) then 
	  msg="WARNING. Excessive memory allocation!"
	  JERR=GOS_ERROR(SRN,MSG,error) 
        endif  
!HJR 

!transfer over old data
	if(old_size/=0)then
		old_ptr=>buf(lp_buf_old)%ptr(lp%buf_add(lp_buf_old):)
		new_ptr=>buf(lp_buf_new)%ptr(1:old_size)

		if(size(new_ptr)/=size(old_ptr))then
			write(nsize,'(i9)')size(new_ptr)
			write(osize,'(i9)')size(old_ptr)
		msg="new_ptr:"//nsize//" old_ptr:"//osize//" not the same"
			JERR=GOS_ERROR(SRN,MSG,2) 
			write(25,4325)size(new_ptr),size(old_ptr)
4325	format(' New_ptr length:',i9,' Old_ptr length:',i9,' Not the same')
		endif
			
!copy it over
		new_ptr=old_ptr		!This is a 'vector' copy
!re define to remainder of buffer
		new_ptr=>buf(lp_buf_new)%ptr(old_size+1:)

	else
		new_ptr=>buf(lp_buf_new)%ptr
	endif
!Were done with the old buffer. Deallocate it.
	if(lp_buf_old/=0)then
            nw = nw - size(buf(lp_buf_old)%ptr) 
            deallocate(buf(lp_buf_old)%ptr)
	endif
!Now read in the new data


	if(lp%length>0)then
	 	cb(1)=lp%length		!set up word count array.
		cb(2)=0	
		cb(3)=0
		cb(4)=0

!now read in lp memory, syncronously using the write memory address pointer.
! It may be faster to do this
!Note that this is a 24 bit read.
							 !All data is contained
							  !in 32 bit data words
!		status=fcfubc(f0,list_proc%ext_reg_code(a1),%ref(new_ptr),cb)
!		status=fcfubr(f0,list_proc%ext_reg_code(a1),%ref(new_ptr),cb)
!HJR 
		status=fcfubr(f0,list_proc%ext_reg_code(a1),temp,cb)
		buf(lp_buf_new)%ptr(old_size+1:) = temp(1:lp%length) 
!HJR
		if(.not.btest(status,0)) call gos_signal(srn,status)
!Hardware Check: Check that the lp read worked.			
		resub=0
       		do
		   if(cb(2).ne.lp%length)then
	   		resub=resub+1
			write(crate_id,'(i2)')list_proc%crate
			msg="Read of data from LP in Crate #"//&
		    	&crate_id//" using FCFUBR command Failed."
	       		JERR=GOS_ERROR(SRN,MSG,31) 
			if(resub.gt.3)then
				msg="It does not work. I quit! Aborting Run!"
				JERR=GOS_ERROR(SRN,MSG,31) 
				gpr10_ctrl%quit=.true.
				return
			else
				msg="Attempting to recover by resubmission of&
				    &  FCFUBR"
				JERR=GOS_ERROR(SRN,MSG,31) 
!Reload write memory address pointer since our failed read may have changed it.
				status=fcfsa(f17,list_proc%ext_reg_code(a1),&
				       &lp%start,q)
				if(.not.btest(status,0)) &
						& call gos_signal(srn,status)
!Reread the data
			 	cb(1)=lp%length	      !set up word count array.
				cb(2)=0	
				cb(3)=0
				cb(4)=0

!HJR 				status=fcfubr(f0,list_proc%ext_reg_code(a1),&
! 				       & %ref(new_ptr),cb)
 				status=fcfubr(f0,list_proc%ext_reg_code(a1),&
 				       & temp,cb)
               		        buf(lp_buf_new)%ptr(old_size+1:) = & 
                                   temp(1:lp%length) 
!HJR 
				if(.not.btest(status,0)) &
						&call gos_signal(srn,status)  

			endif

		   else
			exit		!It worked! Leave!
	    	   endif
		enddo

!SEt new start address.
		lp%start=lp%start+lp%length
		lp%start=iand(lp%start,mem_mask)
	endif
      endif

    END SUBROUTINE GPR10_GET_I4_BUFFER
!***************************************************************************

    SUBROUTINE GPR10_MERGE_DATA(ierr)    !Merge data

!We now have large blocks of data read from the List processors. WE need to
!process and merge these data into the GDF event records. WE use the event 
!number read in in each event in each crate to synchronize things.  The scaler
!data only goes into the 'FRAME' event. The pedestals that were generated
!at the same time as the SCALERs were read out, are written out as a normal
!events. They are distinguished from normal events by a bit set in the
!trigger module.
!All event data starts with a tag value(lp inst reg). Use that to insure
!integrity.

!NOTE: There is a tricky(SUBTLE)effect here: The scaler LP5 buffer was read out
!	last. This means that if a Pedestal event was put into the LP3 buffer it
!	certainly got into the LP5 buffer. The reverse may not be true. It
!	is perfectly possible that a Pedestal event occured after the readout
!	of LP3 but before the readout of LP5.

!	It is also possible that LP5%length is 0(no new data)and further its
!	possible(maybe even likely) that buf5(lp_buf_new) has 0 data
!	even though the lp1,lp3,lp4 buffers have data.

!	Modified:

!	17/2/98 GHS
!		Redone GPR10_CHECK_INTEGRITY_I2 can come back with IERR as
!		true. If so all we do now is abort the run. WE should be
!		trying for a RESTART.

!	19/5/99 GHS
!		Add a new subroutine GPR10_CRATE5_RESTART that resets crate 5
!		(the scaler crate) when it gets hung without interupting
!		the normal data acquisition. It is called in GPR10_MERGE_DATA
!		Which is were crate 5 health is checked. This new routine
!		is basically a striped down version of GPR10_INIT.

	use camac_def

        IMPLICIT NONE 

	logical,intent(out) :: ierr
	integer*2,dimension(:),pointer :: ptr1,ptr2,ptr3,ptr5
	integer*4,dimension(:),pointer :: ptr4
	logical :: search1,search2,search3,search4,search5
	integer :: jerr
	character(len=16),PARAMETER :: SRN="GPR10_MERGE_DATA"

	character(len=12) :: nxt_st,max_st
	character(len=80) :: msg
	character(len=12) :: ev1_n,ev2_n,ev3_n,ev4_n,ev5_n
	character(len=20) :: dan_n,dal_n
	character(len=10) :: event_id

	integer :: max_event,min_event
        integer :: lp1_min_event,lp2_min_event,lp3_min_event,lp4_min_event
	integer :: i,j,k,l,m,n
	integer*2,dimension(nadc_chan) :: mask_adc
						  !3777 octal lower 11 bits
	integer*2,pointer,dimension(:) :: tptr,sptr
	integer*4,pointer,dimension(:) :: uptr
	integer*4 :: temp4
	integer*2,dimension(2) :: temp2

	real*8 :: time_live,utc_old
	real :: ev_diff,t_diff
	real*8 :: grs2mjd
	integer :: frame_old_event,new_size
 	integer :: i1,i2,itry_count
	logical :: normal,pedestal,do_exit,restart

	type(gdf_ev10_t),pointer :: event	!Points to normal gdf event
						!structure. Used for both
						!normal and pedestal(1 pps)
						!events

	type(gdf_fr10_t),pointer :: frame       !Points to gdf frame buffer.
						!used for pedestal events
	integer*4, parameter :: mask24=2**24-1   !77777777 octal(24 bits)
	integer*4, parameter :: mask12=2**12-1
	integer*2, parameter :: encoder_mask=2**16-1 !77777 octal
	real, parameter :: backlog_time_gap=10.0

	mask_adc=2**11-1 !3777 octal(11 bits)	!Note this is a vector
						!assignment
!Set up pointers at start. Assume none are empty.
	if(list_proc_1%online)then
	 	ptr1=>buf1(lp_buf_new)%ptr
		lp1%buf_done=.false.
		lp1%buf_empty=.false.
		search1=.true.
	else
		search1=.false.
	endif

	if(list_proc_2%online)then
	 	ptr2=>buf2(lp_buf_new)%ptr
		lp2%buf_done=.false.
		lp2%buf_empty=.false.
		search2=.true.
	else
		search2=.false.
	endif

 	ptr3=>buf3(lp_buf_new)%ptr
	lp3%buf_done=.false.
	lp3%buf_empty=.false.
	search3=.true.

	if(list_proc_4%online)then
	 	ptr4=>buf4(lp_buf_new)%ptr
		lp4%buf_done=.false.
		lp4%buf_empty=.false.
		search4=.true.
	else
		search4=.false.
	endif


	if(list_proc_5%online)then
		if(lp5%buf_size(lp_buf_new)>0)then
		 	ptr5=>buf5(lp_buf_new)%ptr
			lp5%buf_done=.false.
			lp5%buf_empty=.false.
			search5=.true.
		else
			lp5%buf_done=.true.
			lp5%buf_empty=.true.
			search5=.false.
		endif
	else
		search5=.false.
	endif

!Now process the events in the buffer


  	do

	   max_event=-1
	   min_event=2**30

	   lp1_min_event=2**30
           lp2_min_event=2**30
           lp3_min_event=2**30
           lp4_min_event=2**30

!NOTE:EXIT. An execution of the EXIT command within this do loop is equivalent
!to asking for more data. The present event data is not lost. GPR10_READ_CAMAC
!just adds new data to the existing data. The data that is kept starts at
!wherever the ptr1,ptr2,ptr3,ptr4,ptr5 are pointing. I'm not sure how efficient
!this scheme will be yet.

!NOTE:CYCLE. An execution of the CYCLE command within this do loop
!causes the buffers with their SEARCH flags set to true to be searched for
!the next event. This shouldn't happen often. It mainly(or only) occurs when
!events in one buffer or other are bad and we need to search for the next good
!event.  This code replaces the old camac_reset that dropped big batches of
!events when something was found wrong(dropped frames). This scheme should
!drop only those events that can't be processed due to some hardware screwup.

!Get next event with same event number in each buffer.

!First check present events
!lp1.(set lp1%buf_done to true if no more complete events in this buffer)    
	   if(search1)then
        	call gpr10_check_integrity_i2(ptr1,lp1,list_proc_1,ierr)
		if(ierr)then
			restart_run=.true.
			ierr=.false.
			return		!Abort/restart
		endif
				!If any of the Normal buffers comes up short
				!its time for us to quit and get more data
		if(lp1%buf_done)then
			exit
		endif
				!Find largest and smallest event number 
				!presently being
				!looked at. They really should be all the
				!same.
	   endif
	   if(lp1%event>max_event)then 
	   	max_event=lp1%event
	   elseif(lp1%event<lp1_min_event)then
	   	lp1_min_event=lp1%event
	   endif

           if(lp1_min_event<min_event)then
                min_event=lp1_min_event
           endif

!lp2.(set lp2%buf_done to true if no more complete events in this buffer)    
	   if(search2)then
        	call gpr10_check_integrity_i2(ptr2,lp2,list_proc_2,ierr)
		if(ierr)then
			restart_run=.true.
			ierr=.false.
			return		!Abort/restart
		endif
				!If any of the Normal buffers comes up short
				!its time for us to quit and get more data
		if(lp2%buf_done)then
			exit
		endif
				!Find largest and smallest event number 
				!presently being
				!looked at. They really should be all the
				!same.
	   endif
	   if(lp2%event>max_event)then 
	   	max_event=lp2%event
	   elseif(lp2%event<lp2_min_event)then
	   	lp2_min_event=lp2%event
	   endif

           if(lp2_min_event<min_event)then
                min_event=lp2_min_event
           endif

!lp3
	   if(search3)then
           	call gpr10_check_integrity_i2(ptr3,lp3,list_proc_3,ierr)
		if(ierr)then
			restart_run=.true.
			ierr=.false.
			return		!Abort/restart
		endif
				!If any of the Normal buffers comes up short
				!its time for us to quit and get more data
		if(lp3%buf_done)then
			exit
		endif
	   endif
	   if(lp3%event>max_event)then 
	   	max_event=lp3%event
	   elseif(lp3%event<lp3_min_event)then
	   	lp3_min_event=lp3%event
	   endif

           if(lp3_min_event<min_event)then
                min_event=lp3_min_event
           endif


!lp4
!Note that lp4 is integer*4 buffer not interger*2 like everyone else.
!Also since lp4 has variable length events we have to do a special search
!to see if we have a complete event there. It also has lots of tags which are
!all checked.  Also, lp4%event_length is set for the present event. For
!all other buffers(lp1,lp2,lp3,lp5) lp%event_length is set when the lp code is
!compiled(GPR10_LP_BUILD).

	   if(search4)then
          	call gpr10_check_integrity_lp4(ptr4,lp4)
				!If any of the Normal buffers comes up short
				!its time for us to quit and get more data
		if(lp4%buf_done)then
			exit
		endif
	   endif
	   if(lp4%event>max_event)then 
	   	max_event=lp4%event
	   elseif(lp4%event<lp4_min_event)then
	   	lp4_min_event=lp4%event
	   endif

           if(lp4_min_event<min_event)then
                min_event=lp4_min_event
           endif

!           print*,'lp1_min,lp2_min,lp3_min,lp4_min:', &
!                  &lp1_min_event,lp2_min_event,lp3_min_event,lp4_min_event


		 	
!lp5.                   !This won't be searched if no events in buffer.
	   if(search5)then
               
           	call gpr10_check_integrity_i2(ptr5,lp5,list_proc_5,ierr)
		if(ierr)then
			restart_run=.true.
			ierr=.false.
			return		!Abort/restart
		endif
				!Its very possible for the scaler buffer to
				!come up short or empty, But we may not need 
				!it yet.
	   endif

!At this point all normal event buffers have a complete event(LP5 may not).
!If at any time we came up short in lp1,lp3,lp4 we did an EXIT and got more
!data so that this would be true.
!Now check the event numbers. Possibilities are:

!In order to remove the absolute requirement for a working TRIGGER bit register
!(ie we want to be able to set TRIGGER%online=.false) we don't use the trigger
!bits to tell us when we have a pedestal event. If the event numbers match we
!know its a pedestal event and we know that we can't get a pedestal event in
!lp1,lp2,lp3,lp4 without getting one in LP5(LP5 is readout last, see note above)

!Possible cases:
!1: MAX_EVENT is a normal (or pedestal) event because and all of the normal 
!   event numbers are the same and lp5 is empty=> proccess as normal event
!	(max_event==min_event).and.lp5%buf_done

!2: MAX_EVENT is a normal  event because all of the normal 
!   event numbers are the same and lp5 is >max_event=> process as normal event
!	max_event==min_event.and.(.not.lp5%buf_done).and.lp5%event>max_event

!3: MAX_EVENT is a Pedestal event because all event numbers including lp5 are
!   all the same=>process Pedestal event. 
!	max_event==min_event.and.(.not.lp5%buf_done).and.lp5%event==max_event


!4: MAX_EVENT is some type of event greater then LP5 and lp5 is complete=>
!   write out the LP5 event by itself.
!      	max_event==min_event.and.(.not.lp5%buf_done).and.lp5%event<max_event

!5: The event numbers (lp1,lp2,lp3,lp4) are not the same.=> Skip an event in
!   each buffer that is not the same as MAX_EVENT and then CYCLE(see above).
!	max_event/=min_event

 	   if(max_event==min_event)then
!1:
	     	if(list_proc_5%online)then
		   if(lp5%buf_done)then				!Normal event
			normal=.true.
			pedestal=.false.
               
!2:
		   else
			if(lp5%event>max_event)then 		!Normal event
				normal=.true.
				pedestal=.false.
              
!3:
			elseif(lp5%event==max_event)then  	!Pedestal
				normal=.true.
				pedestal=.true.
                  
!4:
			else					!Scaler only
				normal=.false.
				pedestal=.true.
              
			endif
		    endif
	     	else
			normal=.true.
			pedestal=.false.
	     	endif
!Allocate the buffers
                jerr=0
		if(normal)then
			if(pedestal)then
		     		call gbm_allocate(event,frame,jerr)
			else
				call gbm_allocate(event,ierr=jerr)
			endif
	  	   else
!!!  no, give me an event, any event will do 
                     	call gbm_allocate(event,frame=frame,ierr=jerr)
			search1=.false.
			search2=.false.
			search3=.false.
			search4=.false.
		endif

!See if weve maxed out.
		if(jerr/=0)then
			!We are maxed out on events backed up to be written
			!out to disk, that is:by more then GBM_EV10_MAX events
			!(nominally gbm_ev10_max=4096)
			!WE will go to sleep here for
			!BACKLOG_TIME_GAP seconds so the writer thread can
			!get a chance to reduce the backlog.Folkloare is it
			!takes 5 millsec to writeout an event.

			!If this is a normal event we will pause the data
			!acquisition before we go to sleep. For nitrogen runs
			!we already are paused.
			if(.not.gpr10_ctrl%nitrogen_run)then
							!Ask LP's to pause 
				CALL GPR10_REQUEST_PAUSE			    		!At this point DAQ is suspended. 
			endif

		!Now sleep.
		        CALL GPR10_WAIT(backlog_time_gap)

		!Try again
			jerr=0
		    	if(normal)then
			     if(pedestal)then
				call gbm_allocate(event,frame,jerr)
			     else
				call gbm_allocate(event,ierr=jerr)
			     endif
    			else
               		     call gbm_allocate(event,frame=frame,ierr=jerr)
			     search1=.false.
			     search2=.false.
			     search3=.false.
			     search4=.false.
		       	endif
		!Quit if it doesn't work this time.
			ierr=.false.
		       	if(jerr/=0)then
			        write(event_id,'(i10)')da_next_event
				msg="GBM_ALLOCATE out of room at #"//event_id
				JERR=GOS_ERROR(SRN,MSG,32) 
				ierr=.true.
				return
		        else
						!For normal runs reopen gate
				if(.not.gpr10_ctrl%nitrogen_run)then
				        write(event_id,'(f6.1)')backlog_time_gap
	msg="Time gap of "//event_id//" sec. to reduce event backlog."
					JERR=GOS_ERROR(SRN,MSG,32) 
					        ! open gate. THis starts the Run
 	       				CALL GPR10_OPEN_GATE
				endif
			endif
		endif

!Lp1,lp3,lp4 don't have the same event numbers.
!Find out which aren't the same and set search flags and CYCLE.
	   else
		if(max_event>da_next_event)then
			write(ev1_n,'(i12)')lp1%event
			write(ev2_n,'(i12)')lp2%event
			write(ev3_n,'(i12)')lp3%event
			write(ev4_n,'(i12)')lp4%event
   msg="Mismatch:1)"//ev1_n//" 2)"//ev2_n//" 3)"//ev3_n//" 4)"//ev4_n

			JERR=GOS_ERROR(SRN,MSG,32) 
			da_next_event=max_event
		endif

		if(list_proc_1%online)then
		   if(lp1%event/=max_event)then
			call gpr10_step_buf(lp1,ptr1,search1)
			if(lp1%buf_empty)then
				exit
			endif
		   endif
   		endif

		if(list_proc_2%online)then
		   if(lp2%event/=max_event)then
			call gpr10_step_buf(lp2,ptr2,search2)
			if(lp2%buf_empty)then
				exit
			endif
		   endif
   		endif
		if(lp3%event/=max_event)then
			call gpr10_step_buf(lp3,ptr3,search3)
			if(lp3%buf_empty)then
				exit
			endif
		endif
 		if(list_proc_4%online)then
		    if(lp4%event/=max_event)then
		    	call gpr10_step_buf_lp4(lp4,ptr4,search4)
	    		if(lp4%buf_empty)then
			      	exit
		        endif
		    endif
		endif
		cycle              !Get here if we have to search some more.
	    endif

!Gets here with a good event in the buffers and the GDF buffers allocated and
!ready to fill. Do some error checking on the event numbers fisrt
!	    if(max_event>da_last_event+2)then
            if(max_event>da_last_event+3)then
	    	write(nxt_st,'(i12)')da_last_event+1
		write(max_st,'(i12)')max_event-1
	msg="Errors cause skipped events:"//nxt_st//" to "//max_st
		JERR=GOS_ERROR(SRN,MSG,32) 
	    elseif(max_event>da_last_event+1)then
	    	write(nxt_st,'(i12)')da_last_event+1
	msg="Errors cause skipped event:"//nxt_st
		JERR=GOS_ERROR(SRN,MSG,32) 
!	    elseif(max_event/=0.and.max_event<da_last_event+1)then
            elseif(max_event/=0.and.max_event<da_last_event)then
	    	write(nxt_st,'(i12)')max_event
		msg="Duplicate event, probably due to misread MALU. Event "&
		    &//nxt_st
               
		JERR=GOS_ERROR(SRN,MSG,32) 
	    endif
			!After a restart first event is always event #0(why? I
			!dont know?!?!) Don't reset da_next event if that is
			!so.
	    if(max_event/=0.or.da_next_event==0)then
		    da_next_event=max_event+1
		    da_last_event=max_event
	    endif

!Goody, now we can make up the new event.
!We will go through the crates fillin in stuff.
!EVENT
	    if(normal)then
		event%run=gdf_run%run
		event%nphs=0			!Number of Phase TDC channels.
!		event%nadc=(nadc1+nadc3)*nadc_chan !number of ADC's channels
						!number of ADC's channels
		event%nadc=(nadc1+nadc2+nadc3)*nadc_chan
					 	!Number of scalers
		event%nbrst=0
!LP3:EVENT
		event%event=lp3%event
	   	gpr10_status%event=event%event	

				!Now load up ADC's. LP2 comes last(its got the
				!added pmt's.
!LP1:ADC's
		do i=1,nadc1
		    if(adc1(i)%online)then
			m=adc1(i)%start
			n=adc1(i)%end
			sptr=>ptr1(m:n) !Point to the data from this adc(I).

			j=(i-1)*nadc_chan+1
			k=j+(n-m)
			tptr=>event%adc(j:k)			!move them
			tptr=iand(sptr,mask_adc)!keep only lower 11 bits
						!10 bits data,bit 11 is
						!overflow
		    endif
		enddo
!End lp1 data


!lp3:ADC's
	   	do i=1,nadc3
		    if(adc3(i)%online)then
			m=adc3(i)%start
			n=adc3(i)%end
			sptr=>ptr3(m:n) !Point to the data from this adc(I).

			j=(i+nadc1-1)*nadc_chan+1
			k=j+(n-m)
					!GDF record where these ADC is to go
					!Point to the place in the
			tptr=>event%adc(j:k)			!move them
			tptr=iand(sptr,mask_adc)		!move them
						!keep only lower 11 bits
						!10 bits data,bit 11 is
						!overflow
		   endif
	   	enddo
!LP2:ADC's
	       if(list_proc_2%online)then
		do i=1,nadc2
		    if(adc2(i)%online)then
			m=adc2(i)%start
			n=adc2(i)%end
			sptr=>ptr2(m:n) !Point to the data from this adc(I).

			j=(i+nadc1+nadc3-1)*nadc_chan+1
			k=j+(n-m)
			tptr=>event%adc(j:k)			!move them
							!Vector arith.
			tptr=iand(sptr,mask_adc)!keep only lower 11 bits
						!10 bits data,bit 11 is
						!overflow
		    endif
		enddo
	       endif
!End lp2 data

!lp3:RA and DEC Encoders.
		!This module is a single 16 bit pattern register that indicates
		!has he 15bits of ra encoder value
	        if(ra%online)then
			m=ra%start
			event%track(1)=iand(ptr3(m),encoder_mask)
		endif
		!This module is a single 16 bit pattern register that indicates
		!has he 15bits of dec encoder value
	        if(dec%online)then
			m=dec%start
			event%track(2)=iand(ptr3(m),encoder_mask)
		endif

	
!lp3:HYTEC_GPS clock
		!This come in as 6 16 bit words. Last 2 are status
		!I don't know yet how to convert so stick in a dummy
		!call for now.
	        if(hytec_gps%online)then
	    		m=hytec_gps%start
		       	n=hytec_gps%end
			sptr=>ptr3(m:n) !Point to the Hytec gps clock data
				!Convert raw time to mjd,sec,ns and place into
				!event record
			call gpr10_decode_hytec_gps(sptr,event)	
		endif
		

!lp3:TRIGGER unit.
		!This module is a single 16 bit pattern register that indicates
		!the trigger type of this event.(Normal or Pedestal for
		!now)

		if(trigger%online)then
			m=trigger%start
			event%trigger=ptr3(m)
			i1=event%trigger
			i2=gdf_trig_ped		!Pedistal bit position

		!If we have a pedistal event and no scaler buffer see if 
		!crate 5 is hung is reason
			if(normal.and.(.not.pedestal).and.btest(i1,i2).and. &
				& (.not.restart))then
							!Check lp5 status
		!Tricky logic here with restart. If we can't restart crate 5 
		!restart=.true. This prevents from trying a second time. ie we
		!just leave the scalers disabled but continue with the run.
	 		      call gpr10_lp_test(lp5,list_proc_5,restart)
						!If Restart comes back true
						!Crate 5 is dead in the water.
			      if(restart)then
						!Restart crate 5. This will 
						!cause no lost events just a 
						!few pedistal events without 
						!scaler data.
			  	call gpr10_crate5_restart(ierr)

			     	if(ierr)then
    				   msg="Failure to restart crate 5. Scalers  &
					& disabled for rest of run."
				   JERR=GOS_ERROR(SRN,MSG,1) 
				   ierr=.false.
						!Leave restart=.true.
						!Prevents multiple passes
						!throug this code. i.e. scalers
						! get disabled.
			        else
    				   JERR=GOS_ERROR(SRN,"Crate 5 RESTART, No &
				        &events lost",1)
				   restart=.false.
				endif
			      endif
		        endif
		endif
!End of lp3 crate.


!LP4:GRS2
					!Wisconsin interface to True-Time GPS
					!clock
		if(grs2%online)then
		    	m=grs2%start
		       	n=grs2%end
			uptr=>ptr4(m:n) !Point to the GRS2 clock data
			event%grs_clock=iand(uptr,mask24)
			event%utc=grs2mjd(uptr)	!Rod Lessard's C routine.
!amb	
!			write(874,*) ptr4(m:n)
		endif

!lp4:LIVE_TIME scaler
		if(live_time%online)then
		    	m=live_time%start
		!      printf("LeCroy load, q:%d \n",q_resp);print *,ptr4(m:m+3)
    			uptr=>ptr4(m:m+1) !Point to the live time data from 
					  !this scaler. uptr is i*4
                                          

!lp4:LIVETIME

!lp4:LIVE_SEC
				!Seconds part of Live time since start of run
			 	!Using the Lecroy 2551 Scaler live time is in
				!2 24 bit words held in 2 32 bit words.
				!(169+ days before rollover)
				!Raw livetime in LIVE_OSC counts/sec
				!time_live is r*8
			call gpr10_48bit_convert(uptr,time_live)
			time_live=time_live/live_osc	!live_osc is count rate
							! per/sec
			event%live_sec=time_live	!Save seconds	
							!Integer round down.
				!Look for resetting of livetime scaler.
			if(event%live_sec<live_sec_old)then
				write(msg,'("Livetime scaler reset.Old &
		& live_sec:",i10,"New:",i10)')live_sec_old,event%live_sec
				JERR=GOS_ERROR(SRN,MSG,1) 
			endif
			live_sec_old=event%live_sec

			 !lp4:LIVE_NS
				!Fraction of sec elapsed time converted to nsec
				!Get fraction of seconds
			time_live=time_live-event%live_sec
						!Convert to integer nano-sec
			event%live_ns=time_live*1.d9    
!lp4:ELAPSED TIME
			uptr=>ptr4(m+2:m+3) !Point to the elapsed time data 
						!from this scaler.
                                            
!lp4:ELAPSED_SEC
				!Seconds part of Elapsed time since start of run
			call gpr10_48bit_convert(uptr,time_live)
			time_live=time_live/live_osc	!live_osc is count rate
							! per/sec
			event%elapsed_sec=time_live	!Save seconds	
							!Integer round down.
!lp4:ELAPSED_NS

!			write(874,*) ptr4(m:m+3)
!			write(874,*) time_live

				!Fraction of sec elapsed time converted to nsec
				!Get fraction of seconds
			time_live=time_live-event%elapsed_sec
						!Convert to integer nano-sec
			event%elapsed_ns=time_live*1.d9

	 	endif


!lp4:PST
	   	do i=1,npst
		    if(pst(i)%online)then	!Find the first one.
 			m=pst(i)%start+1	!start of pst data in event.
			uptr=>ptr4(m:) !Point to the data from the pst's
			exit
		    endif
		enddo

		k=3		  !Points to list of 'end' tags for pst's
				  !All tags were checked by integrity check.
		j=1		  !index points to first pst data word.
				  !(may be first 'end-tag if no data from this
				  !pst)
		l=1		  !Point to first position in gdf pattern array
	   	do i=1,npst
		   if(pst(i)%online)then
				  !Loop through data words looking for end tag
				  !for this pst. Load data words into pattern
				  !array until we do. Be sure to set slot
				  !number into high byte of data word.
		      do
				  !See if not at end for this pst
				  !Note: all data words are 0 or have bits set
				  !in third byte


			if(iand(uptr(j),mask12)/=lp4%tag(k))then
				  !Not end yet. Must be data word. Set slot
				  !into upper byte.
			    event%pattern(l)=iand(uptr(j),mask24)+ &
							& pst(i)%slot*(2**24)
			    l=l+1		!Bump pointer of destination
			    j=j+1		!Bump pointer of source
			 else
			    j=j+1		!Bump over tag
			    k=k+1		!bump to next tag
			    exit
			 endif
		      enddo
		   endif	
	   	enddo
		event%ntrg=l-1        !Number of pst data words in event%pattern

!                if (event%ntrg.GT.0) then 
!                  print* 
!     		  print*,event%ntrg 
!                  print '(1x,5(2x,Z8.8))',event%pattern(1:event%ntrg)
!                  print* 
!                endif 

	    endif	!Endf of NORMAL check

!LP5:	Now we see if this was an Pedestal event
!Check the pattern register.
	    if(pedestal)then		!Process  lp5 into a frame record
          
!Load up frame stuff
					!If we had a normal readout we can load
					!times
		if(normal)then
	                frame%utc=event%utc
			frame%gps_mjd=event%gps_mjd !GPS times from Hytec clock
			frame%gps_sec=event%gps_sec !in LP4
			frame%gps_ns=event%gps_ns
			frame%gps_status=event%gps_status	!vector load
		endif

		frame%run=gdf_run%run
		frame%frame=lp5%event
		frame%nphs=0			!Number of Phase TDC channels.
		frame%nadc=0			!ADC ped's are in event record
					 	!Number of scalers
		frame%nsca=(n_lecroy_scaler+n_phillips_scaler)*32


	!Scalers
		!zero them first. Off line is 0 for display
		frame%scals=0

		!LP5:Lecroy 4434 scalers
		do i=1,n_lecroy_scaler
			!Test is this scaler is to be read out.
			if(lscal(i)%online)then
				m=lscal(i)%start
				n=lscal(i)%end
				sptr=>ptr5(m:n) !Point to the data from
						! this scaler.
				j=(i-1)*32+1
				k=j+(n-m)
				frame%scals(j:k)=sptr !move them
			endif
		enddo
!LP5:Phillips 3420 scalers
		do i=1,n_phillips_scaler
			!Test is this scaler is to be read out.
			if(pscal(i)%online)then
				m=pscal(i)%start
				n=pscal(i)%end
				sptr=>ptr5(m:n) !Point to the data from
						! this scaler.
				j=(n_lecroy_scaler+i-1)*32+1
				k=j+(n-m)
				frame%scals(j:k)=sptr !move them
			endif
		enddo

!Determin event rate since last good frame record.
		if(utc_old.ne.0.and.normal)then
			t_diff=(frame%utc-utc_old)*seconds_in_day
			ev_diff=frame%frame-frame_old_event
			gpr10_status%rate=ev_diff/t_diff
					!Determin a new minimum buffer size
					!dependent on trigger rate.
					!Let 100 hz be equivalent to whatever 
					!lp1_max_buffer_size is.
			new_size=(gpr10_status%rate/100.0)*lp1_max_buffer_size
			new_size=min(new_size,lp1_max_buffer_size)
			lp1_min_buffer_size=max(new_size,500) !Never let it get
								!too small
					!Save for next rate calculation.
			frame_old_event=frame%frame
			utc_old=frame%utc
                   
		endif

	   endif
!Now advance all used buffers
!We step over the event read out and have 2 possiblities:
!1:Another event(complet or partial) is contianed in the buffer.
!2: no more data in the buffer.
!The get_data routine uses the lp%buff_empty to tell it if we have emptied the
!buffer or not.
!Step every body before going to get more data(if we need to).
	   do_exit=.false.
	   if(normal)then
		if(list_proc_1%online)then
			call gpr10_step_buf(lp1,ptr1,search1)
			if(lp1%buf_empty)then
			       do_exit=.true.
			endif
		endif
		if(list_proc_2%online)then
			call gpr10_step_buf(lp2,ptr2,search2)
			if(lp2%buf_empty)then
			       do_exit=.true.
			endif
		endif
!lp3 check.
		call gpr10_step_buf(lp3,ptr3,search3)
		if(lp3%buf_empty)then
		       do_exit=.true.
		endif

!Due to variable length of lp4 we always have to search to see if a full event
!is there.lp4%event_length was set to the last event's  length.
		if(list_proc_4%online)then
			call gpr10_step_buf_lp4(lp4,ptr4,search4)
			if(lp4%buf_empty)then
			       do_exit=.true.
			endif
		endif
	   endif

!Advance LP5
	   if(list_proc_5%online)then
	   	if(.not.pedestal)then
	   		search5=.false.
	   	else
	   		call gpr10_step_buf(lp5,ptr5,search5)
			if(lp5%buf_empty)then
				search5=.false.
			endif
	  	endif
  	    endif
!Done. We can now send these record on there way on their way.
!Here we have a frame record and its associated pedestal record in event
	    if(do_exit)then
		 exit
	    endif
	enddo

!We get here by an EXIT command which is given when it is decided we need more
!data.
!Save new values for the pointers(for partial events only)
	if(list_proc_1%online)then
		if(.not.lp1%buf_empty)then
	  	   lp1%buf_add(lp_buf_new)=lp1%buf_size(lp_buf_new)-size(ptr1)+1
		endif
	endif

	if(list_proc_2%online)then
		if(.not.lp2%buf_empty)then
	  	   lp2%buf_add(lp_buf_new)=lp2%buf_size(lp_buf_new)-size(ptr2)+1
		endif
	endif

	if(.not.lp3%buf_empty)then
	   	lp3%buf_add(lp_buf_new)=lp3%buf_size(lp_buf_new)-size(ptr3)+1
	endif
	if(list_proc_4%online)then
		if(.not.lp4%buf_empty)then
	   	   lp4%buf_add(lp_buf_new)=lp4%buf_size(lp_buf_new)-size(ptr4)+1
		endif
	endif

 	if(list_proc_5%online)then
		if(.not.lp5%buf_empty)then
	   	   lp5%buf_add(lp_buf_new)=lp5%buf_size(lp_buf_new)-size(ptr5)+1
		endif
	endif
	ierr=.false.
!debug
	if(size(ptr1)>5000.or.size(ptr2)>5000.or.size(ptr3)>5000.or. &
		& size(ptr4)>5000.or.size(ptr5)>5000)then
		print*,' size1,size2,size3,size4,size5:',size(ptr1), &
			&size(ptr2),size(ptr3),size(ptr4),size(ptr5)
	    print*,'lp1%length,lp2%length,lp3%length,lp4%length,lp5%length:', &
	    		&lp1%length,lp2%length,lp3%length,lp4%length,lp5%length
	endif
!enddebug
	return
    END SUBROUTINE GPR10_MERGE_DATA
!***************************************************************************

    SUBROUTINE GPR10_CHECK_INTEGRITY_I2(ptr,lp,list_proc,ierr)
!Check the integrity of the data for the next event to be processed.
!Check the leading tag, check complete event in buffer, get event number
!of event
!This is for Integer*2 buffers

!Modified:

!	17/2/98 GHS
!		Add a check of the event number to insure corerct tag is found.
!		Major re format of this routine to do this.
!		Add IERR into argument list. Used to indicate when we are
!		so corrupted we have to restart.

	use camac_def
        IMPLICIT NONE 

	type(lp_data) :: lp
	type(camac_module) :: list_proc
	integer*2,dimension(:),pointer :: ptr,tptr
	character(len=10) :: event_id,found
	character(len=2) :: crate_id
	integer :: jerr
	character(len=24),PARAMETER :: SRN="GPR10_CHECK_INTEGRITY_I2"
	character(len=80) :: msg
        integer :: remains
	integer :: i,nwords,icheck,maxmiss,j,k
	integer*4,parameter :: mask12=2**12-1
	logical :: ierr,debug_flag

	!Search for next good tag.
	!If the first word is a bad tag we must then have corrupeted data.
		!Try to recover by searching through the rest of the buffer for
		! the start of the next good event. Search until we find a good
		! event or we run out of buffer. When we find a good event 
		! reposition ptr to its start.
	nwords=size(ptr)
	icheck=0
	ierr=.false.
	do i=1,nwords
	    if(iand(ptr(i),mask12)/=lp%tag(1))then	!Check tag.
		if(i==1)then                            !It really should be
							!the first one. If not
							!complain loudly.
		    write(event_id,'(i10)')da_next_event
	    	    write(crate_id,'(i2)')list_proc%crate
		    msg="Bad tag found in Crate #"//crate_id//". Next expected &
		    			& normal event was"//event_id
		    JERR=GOS_ERROR(SRN,MSG,32) 
		    msg="Searching for next good tag."
		    JERR=GOS_ERROR(SRN,MSG,32) 
!debug
		    write(25,4301)list_proc%crate,da_next_event, &
			& lp%event_length,size(ptr)
4301	format(' Bad tag:crate:',i4,' event#',i10,' event_length:',i10,&
				& 'ptr_length',i10)
		    write(25,4302) lp%tag
4302	format(' TAGS are:',10i5)
		    write(25,4304)ptr(i),iand(ptr(i),mask12),i
4304	format(' Bad tag:',i10,' Bad tag masked:',i5,' Bad Tag position:',i5)
		    write(25,4303)' event data:'
4303	format(' ',a)
			k=min(size(ptr),lp%event_length+5)
		    write(25,4300)(ptr(j),j=1,k)
4300	format(' ',8i9)
!endebug

		else
			cycle
		endif
	    else			!Ok we find a good tag but double check
					!by making sure the event number(if we
					!have a complte event in bugffer.
			!Check length in buffer. Assume fixed length events
		tptr =>ptr(i:)
		remains=size(tptr)
		if(remains<lp%event_length)then
		    lp%buf_done=.true.          !Not enough for an event.
		    lp%buf_empty=.false. 	!set up flags so we can do the
		    ptr =>ptr(i:)		!event number check next time.
		    return
		else
						!We have a complete event
						!get event number(always second
						!and third word in event data.
		    lp%event=transfer(tptr(2:3),lp%event)

		    if(list_proc%crate/=5)then
			maxmiss=1400 !if not crate 5 let it be a max of 1400 
				        !events missing. 2**18/183=1432=max#
					!events in lp1 memory
				!This identifies wrap arounds also
		    else
		    	maxmiss=10000  !More space for 1/sec events in crate 5
		    endif

		    if(lp%event<da_next_event+maxmiss)then  
			ptr =>ptr(i:)      !Good event.
			lp%buf_done=.false.
			lp%buf_empty=.false. 
			return
		    else
					!Count how many times we got good tags
					!but bad event numbers.
 			icheck=icheck+1
			if(icheck>25)then	!Quit big time. Abort and
			    write(event_id,'(i10)')da_next_event
			    write(found,'(i10)')lp%event
		    	    write(crate_id,'(i2)')list_proc%crate
		    msg="Event number found way out of range:expected:"//  &
			  & event_id//"	found:"//found//"  crate"//crate_id
			    JERR=GOS_ERROR(SRN,MSG,32) 
			    ierr=.true.		!Restart
			    da_next_event=da_next_event+2400	!This is to
					!make up for all the skipped events due
					!to the wrap around. Its taking a 
					!chance that the tags will be good for 
					!possible 1000 events.
			    return
			endif		
		        cycle	 		!keep looking
		    endif
		endif
            endif
	enddo
			!We emptied the buffer looking for a good tag.
	lp%buf_done=.true.	!Get more data
	lp%buf_empty=.true.     !No partial events.
	return
    END SUBROUTINE GPR10_CHECK_INTEGRITY_I2
!***************************************************************************

    SUBROUTINE GPR10_CHECK_INTEGRITY_LP4(ptr,lp)
!Check the integrity of the data in LP4 buffer for the next event to be 
!processed. This is special code for the LP4 buffer since it is variable in
!length and has multiple tags. We check all tags.
!We determine event length(lp4%event_length) for the given event, we
!verify the complete event is in the buffer and we get the event number.
	use camac_def

        IMPLICIT NONE 

	type(lp_data) :: lp

	integer*4,dimension(:),pointer :: ptr
	character(len=10) :: event_id,tagexp,taggot
	integer :: jerr
	character(*),PARAMETER :: SRN="GPR10_CHECK_INTEGRITY_LP4"
	character(len=80) :: msg
!HJR	integer*2,dimension(2) :: temp2
!HJR	integer*4,dimension(2) :: temp4
!HJR	integer*4,parameter :: mask=2**16-1
	logical*2,dimension(2) :: temp2
	logical*4,dimension(2) :: temp4
 	logical*4,parameter    :: mask='FFFF'X

	integer*4,parameter :: mask12=2**12-1
        integer :: remains,i,k,m,nwords,j
	logical :: bad_tag
	integer*4 a


!This loop just finds good event with correct tags. Anytime a bad tag is
!found a CYCLE will drop the present event and go on to the next.
    do
!Check leading tag.
	a=ptr(1)
	if(iand(ptr(1),mask12)/=lp%tag(1))then
           if(verbose)then
		write(event_id,'(i10)')da_next_event
		msg="Bad tag # 1 found in Crate #4. Next expected normal &
		    & event was"//event_id
		JERR=GOS_ERROR(SRN,MSG,1) 
		write(tagexp,'(i10)')lp%tag(1)
		write(taggot,'(i10)')iand(ptr(1),mask12)
		msg="Expected tag"//tagexp//" Got tag"//taggot
		JERR=GOS_ERROR(SRN,MSG,1) 
           endif
!debug
		    write(25,4301)da_next_event,lp%event_length,size(ptr)
4301	format(' Bad tag#1:crate #4: event#',i10,' event_length:',i10,&
			& ' ptr_length',i10)
		    write(25,4302) lp%tag
4302	format(' TAGS are:',10i5)
		    write(25,4303)' event data:'
4303	format(' ',a)
			k=min(size(ptr),2*lp%event_length+5)
		    write(25,4300)(ptr(j),j=1,k)
4300	format(' ',8o9)
!endebug

!Search for next good tag.
				!We have a bad tag which means corrupeted data.
				!Try to recover by searching through the rest 
				!of the buffer for the start of the next good 
				!event. Search until we find a good event or we
				!run out of buffer. When we find a good event 
				!reposition ptr to its start.
		msg="Searching for next good tag."
		JERR=GOS_ERROR(SRN,MSG,32) 
		nwords=size(ptr)
		do i=1,nwords
			if(iand(ptr(i),mask12)==lp%tag(1))then  !we found a word
							! with the 
						   !correct tag value
				ptr=>ptr(i:)
				exit
			elseif(i==nwords)then !We emptied the buffer looking 
						!for a good tag.
				lp%buf_done=.true.
				lp%buf_empty=.true.
				return
			endif
		enddo
	endif

!Check the rest of the tags(bad_tag=.true. if bad and we need to search for a
!new event), see if the complete event is in the buffer(lp%buf_done=.false.)
!and get the event length(lp4%event_length).
	call GPR10_CHECK_LP4(ptr,bad_tag)

	if(.not.bad_tag)then
		exit			!all tags ok
	elseif(lp%buf_done)then
		return
	else
		cycle
	endif
    enddo

!get event number(always second and third word in event data.)
!All these transfers are to combine the 2 malu 16 bit words back into 
!a single 32 bit word without overflows.
        lp%event=transfer(ptr(2:3),lp%event)

	temp4(1)=iand(ptr(2),mask)
	temp4(2)=iand(ptr(3),mask)
	temp2(1)=transfer(temp4(1),temp2(1))
	temp2(2)=transfer(temp4(2),temp2(2))
	lp%event=transfer(temp2,lp%event)
    return
    END SUBROUTINE GPR10_CHECK_INTEGRITY_LP4
!***************************************************************************


    SUBROUTINE GPR10_48BIT_CONVERT(sptr,real_result)
!Convets a 48 bit integer number into a real*8 value
	use camac_def

        IMPLICIT NONE 

	integer*4,pointer,dimension(:) :: sptr

	real*8 :: temp
	real*8,intent(out) :: real_result
	integer*4,parameter :: mask24=2**24-1   !77777777 octal(24 bits) 
	temp=iand(sptr(2),mask24)	!Keep only lower 24 bits
	real_result=temp*(2**24)+iand(sptr(1),mask24)
	return
    END SUBROUTINE GPR10_48BIT_CONVERT
!***************************************************************************

    SUBROUTINE GPR10_SET_DISCS(slot)
!  This subroutine initalizes and sets the thresholds for the LeCroy 3420 
!  Constant Fraqction  Discriminators(CFD)
!	Modified:

!	08/10/97 GHS
!		Add a readout of what values actually got loaded.
!       13/03/02 GHS
!               Add a 'slot' argument to GPR10_SET_DISCS. A value of -1 means
!               update all cfd slots. Otherwise only update/set that slot. Do
!               this to spped up the GPR10_SET_MASK routine

	use camac_def
        IMPLICIT NONE 

	INTEGER   :: dc_thresh                           ! JQ - 980122
	INTEGER   :: chan                                ! JQ - 980122
	INTEGER   :: cfd_mv2dc                           ! JQ - 980122
	INTEGER   :: cfd_dc2mv                           ! JQ - 980122

	INTEGER*4 :: i,j
        character(*),PARAMETER ::SRN="GPR10_SET_DISCS" 
	logical :: gos_error,jerr
	character(len=2) :: crate_id,slot_id	
	integer :: slot,imin,imax

!****************************************************************************
! Check that we want to set their thresholds.
!****************************************************************************
	if(slot.eq.-1)then
		imin=1
		imax=n_cfd_discriminators
	else
		imin=slot
		imax=slot
	endif

	do i=imin,imax
		IF (cfd(i)%online) THEN
					!First load the masks
					!This mask enables/disables individulal
					!channels in the CFD's
!			write(*,*)"CFDs Module ",i," set mask"
			status=fcfsa(f17,cfd(i)%ext_reg_code(0),cfd(i)%mask,q)
			if(.not.btest(status,0)) call gos_signal(srn,status)
 
					!Load the width/deadtime values.
!			write(*,*)"CFDs Module ",i," set width"
			status=fcfsa(f17,cfd(i)%ext_reg_code(1),cfd_width_dead,&
			       & q)
			if(.not.btest(status,0)) call gos_signal(srn,status)

					!Now set the threshold. These are set
					!by some initial command.
			do j=0,15
				chan=(i-1)*16+j+1
				dc_thresh=cfd_mv2dc(chan,cfd(i)%threshold(j))
!				write(*,*)"CFDs Module ",i," channel ",j," wr"
				status=fcfsa(f16,cfd(i)%ext_reg_code(j), &
				       & dc_thresh,q)  ! JQ - 980122
				if(.not.btest(status,0)) &
						& call gos_signal(srn,status)

			enddo
					!Now read threshold back out.
			do j=0,15
				chan=(i-1)*16+j+1
!				write(*,*)"CFDs Module ",i," channel ",j," rd"
				status=fcfsa(f0,cfd(i)%ext_reg_code(j), &
				       & dc_thresh,q)
				cfd(i)%act_threshold(j)= &
					& cfd_dc2mv(chan,dc_thresh);
							! JQ - 980122
				if(.not.btest(status,0)) &
						&call gos_signal(srn,status)

			enddo
		endif
	enddo
	return
    END SUBROUTINE GPR10_SET_DISCS
!******************************************************************************

    SUBROUTINE GPR10_SET_STATE

!-------------------------------------------------------------------------------
!       change module state 
!-------------------------------------------------------------------------------
	USE CAMAC_DEF

        IMPLICIT NONE 

        INTEGER ::      CRATE      ! crate number 
        INTEGER ::     SLOT       ! slot number 
        CHARACTER(len=3) :: STATE      ! new module state ON/OFF
        CHARACTER(len=32) :: CMD        ! command invoked 
        CHARACTER(len=80) :: MSG        ! error message 
        INTEGER  ::     NPAR       ! number of command parameters 
         INTEGER ::      IERR       ! return code         
	integer :: i

        CHARACTER(*), PARAMETER :: SRN = "GPR_SET_STATE" 

        TYPE(CAMAC_MODULE),POINTER :: ptr
	type(cfd_module),pointer :: cfd_ptr

        CALL KUPATL(CMD,NPAR)    ! get command, number of parameters  
	CALL CLTOU(CMD)                      ! convert to upper case 
        CALL KUGETI(crate)                         ! get crate number 
        CALL KUGETI(SLOT)                         ! get slot number 

	if(gpr10_ctrl%run_status)then	!Run in progress. if so leave
        msg="Cannot change module state while run is in progress."
		IERR=GOS_ERROR(SRN,MSG,1) 
		return
	endif
!-------------------------------------------------------------------------------
!       deal with ADCs 
!-------------------------------------------------------------------------------
        IF (CMD=="ADC") THEN 

!----     get user input 

!----     check crate numbe, set pointer 
          IF (CRATE==1) THEN 
            ptr => ADC1(slot) 
          ELSE IF (CRATE==2) THEN 
            ptr => ADC2(slot) 
          ELSE IF (CRATE==3) THEN 
            ptr => ADC3(slot) 
          ELSE 
            MSG  = "There are no ADCs in this crate."
            IERR = GOS_ERROR(SRN,MSG,1) 
            RETURN 
          ENDIF 

!----     change module state
	  call gpr10_change_state(ptr,crate,slot)
          return			     ! makes the change_state 
					     ! routine generic


!-------------------------------------------------------------------------------
        ELSE IF (CMD=="LIST_PROC") THEN 
	  if(crate==3)then
            MSG  = "List Processor in Crate 3 is required. IT can not be put&
		   & offline"
            IERR = GOS_ERROR(SRN,MSG,11) 
	    return
!NOTE:	IF we disable LP1,LP2,LP4, or LP5 we may want to also disable all
!	the modules in these crates. Think about it and maybe add later.
	  elseif(crate==1)then
	    ptr=>list_proc_1
	    call gpr10_change_state(ptr,crate,slot)
	  elseif(crate==2)then
	    ptr=>list_proc_2
	    call gpr10_change_state(ptr,crate,slot)
	  elseif(crate==4)then
	    ptr=>list_proc_4
	    call gpr10_change_state(ptr,crate,slot)
	  elseif(crate==5)then
	    ptr=>list_proc_5
	    call gpr10_change_state(ptr,crate,slot)
	  endif
          return
!-------------------------------------------------------------------------------
        ELSE IF (CMD=="SOB") THEN 
            MSG  = "The SOB's are required. They can not be put offline"
            IERR = GOS_ERROR(SRN,MSG,11) 
	    return
!-------------------------------------------------------------------------------
        ELSE IF (CMD=="MALU") THEN 
            MSG  = "The MALU's are required. They can not be put offline"
            IERR = GOS_ERROR(SRN,MSG,11) 
	    return
!------------------------------------------------------------------------------
!	RA Encoder register
!------------------------------------------------------------------------------
        ELSE IF (CMD=="RA") THEN 
!----     change module state
	  ptr=>ra
	  call gpr10_change_state(ptr,crate,slot)
          return
!------------------------------------------------------------------------------
!	DEC Encoder Register
!------------------------------------------------------------------------------
        ELSE IF (CMD=="DEC") THEN 
!----     change module state
	  ptr=>dec
	  call gpr10_change_state(ptr,crate,slot)
          return
!------------------------------------------------------------------------------
!	LIVE_TIME scaler
!------------------------------------------------------------------------------
        ELSE IF (CMD=="LIVE_TIME") THEN 
!----     change module state
	  ptr=>live_time
	  call gpr10_change_state(ptr,crate,slot)
          return
!------------------------------------------------------------------------------
!	Hytec GPS clock
!------------------------------------------------------------------------------
        ELSE IF (CMD=="HYTEC_GPS") THEN 
!----     change module state
	  ptr=>hytec_gps
	  call gpr10_change_state(ptr,crate,slot)
          return
!------------------------------------------------------------------------------
!	Trigger register
!------------------------------------------------------------------------------
        ELSE IF (CMD=="TRIGGER") THEN 
!----     change module state
	  ptr=>trigger
	  call gpr10_change_state(ptr,crate,slot)
          return
!------------------------------------------------------------------------------
!	GRS2 GPS clock interface
!------------------------------------------------------------------------------
        ELSE IF (CMD=="GRS2_GPS") THEN 
!----     change module state
	  ptr=>grs2
	  call gpr10_change_state(ptr,crate,slot)
          return
!------------------------------------------------------------------------------
!	Michigan Oscillator
!------------------------------------------------------------------------------
        ELSE IF (CMD=="MICH_OSC") THEN 
!----     change module state
	  ptr=>mich_osc
	  call gpr10_change_state(ptr,crate,slot)
          return

!------------------------------------------------------------------------------
!	Scaler
!------------------------------------------------------------------------------
        ELSE IF (CMD=="SCALER") THEN 
!----     change module state
	  if(slot<=n_lecroy_scaler)then
		  ptr=>lscal(slot)
	  else
		  i=slot-n_lecroy_scaler
		  ptr=>pscal(i)
	  endif
	  call gpr10_change_state(ptr,crate,slot)
          return
!------------------------------------------------------------------------------
!	CFD discriminators
!------------------------------------------------------------------------------
        ELSE IF (CMD=="CFD") THEN 
!----     change module state
	  cfd_ptr=>cfd(slot)
	  call gpr10_change_state_cfd(cfd_ptr,crate,slot)
          return
!-------------------------------------------------------------------------------
!       oh, oh ... it's an unknown command
!-------------------------------------------------------------------------------
        ELSE 
          MSG  = "Unknown command "//CMD
          IERR = GOS_ERROR(SRN,MSG,1) 
          RETURN 
        ENDIF 

   END SUBROUTINE GPR10_SET_STATE
!******************************************************************************

   SUBROUTINE GPR10_CHANGE_STATE(ptr,crate,slot)
! Change the state of a module after doing some error checking. Assume
!PTR points to the camac module whos state we are to change.
	USE CAMAC_DEF

        IMPLICIT NONE 

	type(camac_module),pointer :: ptr
        CHARACTER( 3) :: STATE      	! new module state ON/OFF
        INTEGER :: CLEN     			  ! character string length  
        INTEGER,intent(in) :: CRATE  			! crate number 
        INTEGER,intent(in) :: SLOT       			! slot number 
        INTEGER :: IERR       ! return code         
        CHARACTER(LEN=18), PARAMETER :: SRN = "GPR10_CHANGE_STATE" 
        CHARACTER(80) MSG        ! error message 


!----     check crate number 
       IF (CRATE/=ptr%crate) THEN 
            MSG  = "There are not a "//trim(ptr%dev_type)//" module in this&
		   &  crate."
            IERR = GOS_ERROR(SRN,MSG,11) 
            RETURN 
           ENDIF 

       IF (slot/=ptr%slot) THEN 
            MSG  = "There in not a "//trim(ptr%dev_type)//" module in this&
		   &  slot."
            IERR = GOS_ERROR(SRN,MSG,11) 
            RETURN 
           ENDIF 

       CALL KUGETC(STATE,CLEN)                   ! get ON/OFF string 
       CALL CLTOU(state)                      ! convert to upper case 

       IF (STATE=="ON") THEN 
		if(ptr%online)then
	            MSG  = "This "//trim(ptr%dev_type)//" is already ON!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		else
	            ptr%ONLINE = .TRUE.                  
	            MSG  = trim(ptr%dev_type)//" is now ONLINE!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		endif
        ELSE IF (STATE=="OFF") THEN 
		if(.not.ptr%online)then
	            MSG  = "This "//trim(ptr%dev_type)//" is already OFF!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		else
	            ptr%ONLINE = .FALSE.                  
	            MSG  = trim(ptr%dev_type)//" is now OFFLINE!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		endif
        ELSE 
            MSG  = "Sorry. Is it on or Off?"
            IERR = GOS_ERROR(SRN,MSG,2) 
        ENDIF 
        RETURN 
   END SUBROUTINE GPR10_CHANGE_STATE
!******************************************************************************

   SUBROUTINE GPR10_CHANGE_STATE_CFD(ptr,crate,slot)
! Change the state of a CFD module after doing some error checking. Assume
!PTR points to the CFD module whos state we are to change.
	USE CAMAC_DEF

        IMPLICIT NONE 

	type(cfd_module),pointer :: ptr
        CHARACTER( 3) :: STATE      	! new module state ON/OFF
        INTEGER :: CLEN     			  ! character string length  
        INTEGER,intent(in) :: CRATE  			! crate number 
        INTEGER,intent(in) :: SLOT       			! slot number 
        INTEGER :: IERR       ! return code         
        CHARACTER(LEN=18), PARAMETER :: SRN = "GPR10_CHANGE_STATE_CFD" 
        CHARACTER(80) MSG        ! error message 


!----     check crate number 
       IF (CRATE/=ptr%crate) THEN 
            MSG  = "There are not a CFD module in this crate."
            IERR = GOS_ERROR(SRN,MSG,11) 
            RETURN 
           ENDIF 

       IF (slot/=ptr%slot) THEN 
            MSG  = "There in not a CFD module in this slot."
            IERR = GOS_ERROR(SRN,MSG,11) 
            RETURN 
           ENDIF 

	CALL KUGETC(STATE,CLEN)                   ! get ON/OFF string 
        CALL CLTOU(STATE)                      ! convert to upper case 

        IF (STATE=="ON") THEN 
		if(ptr%online)then
	            MSG  = "This CFD is already ON!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		else
	            ptr%ONLINE = .TRUE.                  
		endif
        ELSE IF (STATE=="OFF") THEN 
		if(.not.ptr%online)then
	            MSG  = "This CFD is already OFF!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		else
	            ptr%ONLINE = .FALSE.                  
		endif
        ELSE 
            MSG  = "Sorry. Is it on or Off?"
            IERR = GOS_ERROR(SRN,MSG,2) 
        ENDIF 
        RETURN 
   END SUBROUTINE GPR10_CHANGE_STATE_CFD
!******************************************************************************
!******************************************************************************

   SUBROUTINE GPR10_CHANGE_STATE_PST(ptr,crate,slot)
! Change the state of a PST module after doing some error checking. Assume
!PTR points to the PST module whos state we are to change.
	USE CAMAC_DEF

        IMPLICIT NONE 

	type(PST_module),pointer :: ptr
        CHARACTER( 3) :: STATE      	! new module state ON/OFF
        INTEGER :: CLEN     			  ! character string length  
        INTEGER,intent(in) :: CRATE  			! crate number 
        INTEGER,intent(in) :: SLOT       			! slot number 
        INTEGER :: IERR       ! return code         
        CHARACTER(LEN=18), PARAMETER :: SRN = "GPR10_CHANGE_STATE_pst" 
        CHARACTER(80) MSG        ! error message 


!----     check crate number 
       IF (CRATE/=ptr%crate) THEN 
            MSG  = "There are not any PST modules in this crate."
            IERR = GOS_ERROR(SRN,MSG,11) 
            RETURN 
           ENDIF 

       IF (slot/=ptr%slot) THEN 
            MSG  = "There is no PST module in this slot."
            IERR = GOS_ERROR(SRN,MSG,11) 
            RETURN 
           ENDIF 

	CALL KUGETC(STATE,CLEN)                   ! get ON/OFF string 
	CALL CLTOU(STATE)                      ! convert to upper case 

       IF (STATE=="ON") THEN 
		if(ptr%online)then
	            MSG  = "This "//trim(ptr%dev_type)//" is already ON!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		else
	            ptr%ONLINE = .TRUE.                  
	            MSG  = trim(ptr%dev_type)//" is now ONLINE!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		endif
        ELSE IF (STATE=="OFF") THEN 
		if(.not.ptr%online)then
	            MSG  = "This "//trim(ptr%dev_type)//" is already OFF!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		else
	            ptr%ONLINE = .FALSE.                  
	            MSG  = trim(ptr%dev_type)//" is now OFFLINE!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		endif
        ELSE 
            MSG  = "Sorry. Is it on or Off?"
            IERR = GOS_ERROR(SRN,MSG,2) 
        ENDIF 

       IF (STATE=="ON") THEN 
		if(ptr%online)then
	            MSG  = "This PST is already ON!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		else
	            ptr%ONLINE = .TRUE.                  
		endif
        ELSE IF (STATE=="OFF") THEN 
		if(.not.ptr%online)then
	            MSG  = "This PST is already OFF!"
	            IERR = GOS_ERROR(SRN,MSG,2) 
		else
	            ptr%ONLINE = .FALSE.                  
		endif
        ELSE 
            MSG  = "Sorry. Is it on or Off?"
            IERR = GOS_ERROR(SRN,MSG,2) 
        ENDIF 
        RETURN 
   END SUBROUTINE GPR10_CHANGE_STATE_PST
!******************************************************************************

   SUBROUTINE GPR10_CAMAC_FNA
!-------------------------------------------------------------------------------
!	This is the camac utility routine for the Granite program that 
!	allows	the user to issue single camac commands to the camac crate.
!	Presently we will not check to see if a run is in progress.
!	Be careful!There may be some un-safe trhead code in the HYTEC CAMAC
!	Librarys.
!	The kuip>Camac/fna   command requires a crate number, a camac
!	function code, a slot address, and a sub address. This rouitne
!	will determine the type of command:Non-data transfer, read or
!	write, from the function code given, assuming ieee standards.
!	Q will be returned and some simple error handeling and recovery
!	will be	attempted.
!-------------------------------------------------------------------------------
!	Written by:
!		Glenn Sembroski
!		Physics Dept.
!		Purdue Univ.
!		W.Lafayette, In 47907
!		765-494-5172
!		27/8/97
!-------------------------------------------------------------------------------
!	Modified:
!	27/8/97 GHS
!		This is an adaption of the same routine as was used in the
!		original GRANIT data acquisiton system. Several people 
!		contributed to it: DJB,MAC

	IMPLICIT NONE

        character(*),PARAMETER :: SRN="GPR10_CAMAC_FNA"
	integer :: jerr
	character(len=80) :: msg
	integer :: crate,F,N,A,Q,Data,ext,branch=1
	integer*4 :: status
	logical :: control,reading,writing
	integer*4,parameter :: mask_24=2**24-1
	integer :: fcfsa

!	Get the required parameters.
	call kugeti(crate)
	call kugeti(f)
	call kugeti(n)
	call kugeti(a)

!	Check function code to see if have a read or write code to see if 
!	we need to pick up the DATA parameter.
!	Bits: f16=0 and f8=0 means READ command(get data)
!	      f16=1 and f8=0 means WRITE command(send data)
!	      f16=1,0 and f8=1 means a control command(no data transfered)
		control=.false.
		reading=.false.
		writing=.false.
	if(iand(F,8).ne.0)then
		control=.true.
	elseif(iand(F,16).eq.0)then
		reading=.true.
	else
		writing=.true.
		call kugeti(data)
	endif

!	Make up the cdreg code for the ecc.
	call cdreg(ext,branch,crate,n,a)

!	Now do the commands.
	status=fcfsa(f,ext,data,q)
	if(.not.btest(status,0)) then
          MSG  = "Camac error upon command execution."
          jerr=gos_ERROR(SRN,MSG,5) 
	  call gos_signal(srn,status)
	  return
	endif
	if(reading)then
						!Keep only lower 24 bits.
		data=iand(data,mask_24)		! 77777777   octal
		write(6,1000)" CAMAC/FNA: Command executed. Q:",q, &
			     &"  Data:",data,"  Data(octal):",data
1000	format(a,i2,a,i10,a,o10)
	else
		write(6,1001)" CAMAC/FNA: Command executed. Q:",q
1001	format(a,i2)

	endif
	return
   END SUBROUTINE GPR10_CAMAC_FNA
!******************************************************************************

    SUBROUTINE GPR10_SET_MAX_GAP

!-------------------------------------------------------------------------------
!       Set max gap to wait for lP to get data before declaring them hung
!-------------------------------------------------------------------------------
	USE CAMAC_DEF

        IMPLICIT NONE 

	real :: gap			!Reqested time gap in seconds.

! KUGETI changed to KUGETR by SJF 2001-01-17
        CALL KUGETR(gap)                        !get new time gap
	gpr10_ctrl%max_gap=gap/seconds_in_day	!Convert to MJD
    END SUBROUTINE GPR10_SET_MAX_GAP
!******************************************************************************

    SUBROUTINE GPR10_STEP_BUF(lp,ptr,search)
! Steps us an event in the buffer(We know the present event must be completly
!in the buffer) and checks to see if we have emptied the buffer
	use camac_def

        IMPLICIT NONE 
	type(lp_data) :: lp
	integer*2,dimension(:),pointer :: ptr
	logical :: search


	if(size(ptr) > lp%event_length)then !Another event is in the buffer
		search=.true.
		ptr=>ptr(lp%event_length+1:)
	else
		lp%buf_done=.true.          !Nope that was the end of the
		lp%buf_empty=.true.	    !buffer
	endif
	return
    END SUBROUTINE GPR10_STEP_BUF
!******************************************************************************

    SUBROUTINE GPR10_STEP_BUF_LP4(lp,ptr,search)
! Steps us an event in the LP4 buffer and checks to see if we have emptied
!the buffer.Assumption is that lp[4%event_length is known for the present
!event.
	use camac_def

        IMPLICIT NONE 
	type(lp_data) :: lp
	integer*4,dimension(:),pointer :: ptr
	logical :: search


	if(size(ptr) > lp%event_length)then !Another event is in the buffer
		search=.true.
		ptr=>ptr(lp%event_length+1:)
	else
		lp%buf_done=.true.          !Nope that was the end of the
		lp%buf_empty=.true.	    !buffer
	endif
	return
    END SUBROUTINE GPR10_STEP_BUF_LP4
!******************************************************************************

    SUBROUTINE GPR10_CHECK_LP4(ptr,bad_tag)
!Check all remaining tags.They are all in the PST data. but the event ends with
!the last tag.This also get us the length of the event. If the event is not
!fully contained in the buffer flags are set.
!NOTE: We assume that ptr(1) is the first tag of the event and is correct.
!ie at least one word is in the buffer (ptr)
	use camac_def

        IMPLICIT NONE 

	character(len=10) :: tagexp,taggot,tagk
	integer*4,dimension(:),pointer :: ptr
        integer :: i,j,k,m,nwords,kg
	logical :: bad_tag
	integer :: jerr
	integer*4,parameter :: mask12=2**12-1
	character(*),PARAMETER :: SRN="GPR10_CHECK_LP4"
	character(len=80) :: msg

	bad_tag=.false.
	nwords=size(ptr)
	lp4%buf_empty=.false.	!We can never get lp4%buf_empty since we must
				!have the original tag to start.
	lp4%buf_done=.false.    !We can however run out of data for the event.
!start with pre tag
 	do i=1,npst
 	    if(pst(i)%online)then	!Find the first one.
		m=pst(i)%start		!start of pst data in event.
		if(m>nwords)then 	!Not a full event in buffer. Get more.
			lp4%buf_done=.true.
			return
		endif
		exit
	    endif
	enddo
	if(lp4%tag_count<2)then		!No pst's onliune
					!and lp4%event_length is correct from
					!gpr10_lp_build
				
	   if(nwords >= lp4%event_length)then !An event is in the buffer
		lp4%buf_done=.false.
	   elseif(nwords>0)then	!A partial event is in the buffer
		lp4%buf_done=.true.
           endif
	   return			!The tags are all ok.
	endif
!We have PST's and must check the tags.
	k=2
	if(iand(ptr(m),mask12)/=lp4%tag(k))then
		write(tagexp,'(i10)')lp4%tag(2)
		write(taggot,'(i10)')iand(ptr(m),mask12)
		msg="Bad PST pretag. Expected tag"//tagexp//" Got tag"//taggot
		JERR=GOS_ERROR(SRN,MSG,1) 

					!BAD PRETAG!
         
		ptr=>ptr(m:)	!This just forces us to search.
		bad_tag=.true.
		return
	endif

	do k=3,lp4%tag_count 
		bad_tag=.true.		!We need to turn off bad tag if we find 
					!a good one
	
!used to say m+1+4 SMB 19.10.98
! m+1+6 on 2/2/99
!11/2/99 GHS
!Should say m+1+5: M is at last tag. M+1 is first posibble place of next tag
!( for 0 data words). M+1+4 is last possible place of last data word(if we had
!5 of them), so M+1+5 is last possible place of tag.
        	do i=m+1,m+1+5		!Maximum of 5 words for each pattern
					!If no data, first word will be tag.
			if(iand(ptr(i),mask12)==lp4%tag(k))then  !we found a 
							!word with the 
						   !correct tag value
				bad_tag=.false.
				exit
			elseif(i==nwords)then !We emptied the buffer looking 
					!for a good tag.
				bad_tag=.false.
				lp4%buf_done=.true.
				return
			endif
		enddo
           
      		if(bad_tag)then
                if(verbose)then !SMB 16/2/99
			write(tagk,'(i5)')k
			write(tagexp,'(i10)')lp4%tag(k)
          msg="Bad PST tag #"//tagk//" Expected tag"//tagexp//" Never found it"
			kg=min(size(ptr),2*lp4%event_length+5)
		    write(25,4300)(ptr(j),j=1,kg)
4300	format(' ',8o9)
	      JERR=GOS_ERROR(SRN,MSG,1) 
                endif
			ptr=>ptr(i:)	!This just forces us to search.
			exit		!drop out of loop
		endif
		m=i			!Update for rest of tag search.
	enddo	
	lp4%event_length=i	!Last tag is end of event
!debug
!	if(i<nwords)then
!		if(iand(ptr(i+1),mask12)/=lp4%tag(1))then
!			kg=min(size(ptr),2*lp4%event_length+5)
!			write(25,4031)size(ptr),i
!4031	format(/,' Second buffer has bad first tag.  ptr length=',i10,'event &
!			& length:',i10)
!		    write(25,4300)(ptr(j),j=1,kg)
!		endif
!	endif
	return
    END SUBROUTINE GPR10_CHECK_LP4
!******************************************************************************

   SUBROUTINE GPR10_DECODE_HYTEC_GPS(gpsptr,event)

!	I'm assuming here that we have 4 16bit words of GPS data read out from
!	the module. I'm also assuming that the GDF data is expecting three
!	32bit words of nsec, sec and mjd. 
!
!	As far as I know there is also one 32bit word for status information
!	(called, I believe, gdf_ev10.gps_status). There are two 16bit words 
!	of status information which are only read out during 
!	debugging/reprogramming which could be stored in this word, but this 
!	code won't need to do that.
!
!	The code here need only deal with the 4 words of timing info (which
!	contains 6bits of status anyway).
!
!	AMB
!	Converted to F90 16/9/97 GHS

!	Modified:

!	21/9/98 GHS
!		Fixed bug in converting to MJD.

	use camac_def

	IMPLICIT NONE

	integer*2, pointer,dimension(:) :: gpsptr
	type(gdf_ev10_t),pointer :: event	!Points to normal gdf event
						!structure. Used for both
						!nomral and pedestal(1 pps)
						!events
	integer*4  ::	day, year, stat
	integer  ::   leap_days, years_since

!	First off decode the 4 words into nsec, sec, day and year. This is
!	because the Magnavox GPS engine gives us calender dates rather than
!	MJD.
!	Since we won't get better than 10nsec resolution (because we use a
!	100MHz oscillator) we only read out to that accuracy. Multiply by
!	ten to get nsecs.

	event%gps_ns  = iand(gpsptr(2),2047)  * 65536 + iand(gpsptr(1),65535)
	event%gps_ns  =  event%gps_ns * 10
      	event%gps_sec = iand(gpsptr(3),4095) * 32 +iand(gpsptr(2),65505) / 2048
	day     = iand(gpsptr(4),31)    * 16 + iand(gpsptr(3),61440) / 4096
	year	= iand(gpsptr(4),992)   / 32 + 1996

!Not used yet!
!	stat  = iand(gpsptr(4),64512) / 1024

!	Now I need to convert day into year and year into mjd. 

!	Find out how many leap days occurred in the years since 1996.
!	There'll be at least one (in 1996). I don't expect the clock to
!	still be in use after 30 years. Is that a silly assumption?

	years_since = year - 1996

!	GHS: Is year 2000 a leap year?
!	Yes it is! Centenial years exactly divisable by 400 are leap years.
	leap_days=years_since/4	+ 1	!integer divide, round down.


!	Add all the bits together to get MJD

	event%gps_mjd = 50083	           & ! mjd 1/1/96
!     	    	 &	+ years_since  &    ! 		
!Fixed 21/9/98 GHS
     	    	 &	+ years_since*365  & ! 		
     	   	 &	+ day-1	           & ! jan 1st is zero days since 1/1/96
     	   	 &	+ leap_days    	     ! at least one

!	event%gps_status(1)=gpsptr(5)
!	event%gps_status(2)=gpsptr(6)
	return
   END SUBROUTINE GPR10_DECODE_HYTEC_GPS
!******************************************************************************

   SUBROUTINE GPR10_SET_CFD_MASK
!-------------------------------------------------------------------------------
!       Enable or disable a CFD channel through seting (or clearing) a bit in
!	the mask word of a CFD module.
!       A bit SET in the mask disables that channel.
!	Then use SET_DISC to load all the the thresholds, masks etc into the 
!   	CFDs. Can only be done if we do not have a run in progress.
!       
!-------------------------------------------------------------------------------
!Modified:

!       13/03/02 GHS
!               Add a 'slot' argument to GPR10_SET_DISCS. A value of -1 means
!               update all cfd slots. Otherwise only update/set that slot. Do
!               this to spped up the GPR10_SET_MASK routine

	USE CAMAC_DEF

        IMPLICIT NONE 

        INTEGER :: PMT_NUMBER         	! PMT CHANNEL NUMBER.
        CHARACTER(len=7) :: STATE       ! new channel state ENABLE/DISABLE
	character(len=4) :: pmtnumber
        integer :: clen,i,j,maxpmtnumber,islot

	logical :: mask_set
        CHARACTER(len=80) :: MSG        ! error message 
        INTEGER ::      jERR            ! return code         

        CHARACTER(*), PARAMETER :: SRN = "GPR_SET_CFD_MASK"


	if(gpr10_ctrl%run_status)then	!Run in progeress. if so leave
 msg="Can not set CFD enable/disale while run is in progress. NO CFDs changed."
		JERR=GOS_ERROR(SRN,MSG,32) 
		return
	endif

        CALL KUGETI(pmt_number)                   ! get pmt whose CFD we are to
						  ! enable or disable.
        write(pmtnumber,'(i4)')pmt_number
        maxpmtnumber=max_cfd_channels
	if(pmt_number.gt.maxpmtnumber.or.pmt_number.le.0)then
             msg="Specified Cfd channel #"//trim(pmtnumber)// &
	        &" out of range. NO CFDs changed."
	     JERR=GOS_ERROR(SRN,MSG,32) 
	     return
	endif

				!If mask_set is true, the bit is set and the
			        !channel is disabled.
	call gpr10_getcfdmask(pmt_number,mask_set)

	CALL KUGETC(STATE,CLEN)                   ! get ENABLE/DISABLE string 
	CALL CLTOU(STATE)                      ! convert to upper case 


!Note: A bit SET in the mask DISABLES that channel.
       	IF (STATE=="ENABLE") THEN 
		if(.not.mask_set)then
 				!not disabled.
	         MSG  = "CFD channel "//trim(pmtnumber)//" is already ENABLED!"
	            jERR = GOS_ERROR(SRN,MSG,2) 
		    return
		else
	                               !set bit to 0(.false.) enables channel.
		          	print*,'at 4:'
 			 call gpr10_setcfdmask(pmt_number,.false.)
	            MSG  = "CFD Channel "//trim(pmtnumber)//" is now ENABLED!"
	            jERR = GOS_ERROR(SRN,MSG,2) 
		endif
        ELSE IF (STATE=="DISABLE") THEN 
	if(mask_set)then
	                     !mask bit set means channels is already disabled.
                MSG  = "CFD channel "//trim(pmtnumber)//" is already DISABLED!"
	            jERR = GOS_ERROR(SRN,MSG,2) 
                    return
		else
	            !setting bit to a 1(.true.) disables channel.
 	            call gpr10_setcfdmask(pmt_number,.true.)
	            MSG  = "CFD Channel "//trim(pmtnumber)//" is now DISABLED!"
	            jERR = GOS_ERROR(SRN,MSG,2) 
		endif
        ELSE 
         MSG  = "Sorry. What do you really want? Are we to ENABLE or DISABLE?"
            jERR = GOS_ERROR(SRN,MSG,2) 
        ENDIF 

!Load all CFD values)thresholds, masks etc). Can only be done from here if a
!Run is not in progress. This prevents any non-thread safe Hytec code from
!screwing up.
!crate 6
!CFD's
!	do i=1,n_cfd_discriminators   !Just make sure these are defined for
!                                      !gpr10_set_discs
!		do j=0,n_cfd_chan-1
!			call cdreg(cfd(i)%ext_reg_code(j),branch,cfd(i)%crate, &
!		  	& cfd(i)%slot,j)           
!		enddo
!	enddo

	islot=(pmt_number-1)/16+1
	do j=0,n_cfd_chan-1
		call cdreg(cfd(islot)%ext_reg_code(j),branch,cfd(islot)%crate, &
		  & cfd(islot)%slot,j)           
	enddo

!	Initialise (make a connection to) the ecc manager
!        write(*,*)"CFDS ccinit"
	call ccinit(BRANCH)
!	write(*,*)"CFDS gpr10_set_discs"  !Loads new masks all channels.
 	call gpr10_set_discs(islot)
!HJR 	call ccfini(branch)		!Disconnect from ecc manager
!	write(*,*)"CFDs ccfini"
 	call ccfini			!Disconnect from ecc manager
	return
  END SUBROUTINE GPR10_SET_CFD_MASK
!******************************************************************************


   SUBROUTINE GPR10_SHOW_CFD_DISABLED
!-------------------------------------------------------------------------------
!       List all disabled CFD channels.
!       A bit SET in the mask word of a CFD indicates that it is disabled.
!-------------------------------------------------------------------------------
!Modified:


	USE CAMAC_DEF

        IMPLICIT NONE 

        INTEGER :: PMT_NUMBER         	! PMT CHANNEL NUMBER.
	character(len=4) :: pmtnumber
        integer :: i
        logical :: mask_set,any_disabled
        CHARACTER(len=80) :: MSG        ! error message 
        INTEGER ::      jERR            ! return code         

        CHARACTER(*), PARAMETER :: SRN = "GPR_SET_CFD_MASK"


!Find all disabled cfd channels and list them.
	any_disabled=.false.
	do pmt_number=1,max_cfd_channels
				!If mask_set is true, the bit is set and the
			        !channel is disabled.
		call gpr10_getcfdmask(pmt_number,mask_set)
  	        if(mask_set)then
		  any_disabled=.true.
		  write(pmtnumber,'(i4)')pmt_number
	          MSG  = "CFD channel "//trim(pmtnumber)//" is DISABLED!"
	          jERR = GOS_ERROR(SRN,MSG,2) 
	        endif
	enddo
	if(.not.any_disabled)then
	          MSG  = "All CFD channels are ENABLED!"
	          jERR = GOS_ERROR(SRN,MSG,2) 
	endif
	return
  END SUBROUTINE GPR10_SHOW_CFD_DISABLED
!******************************************************************************

  SUBROUTINE GPR10_GETCFDMASK(pmt_number,state)
!******************************************************************************
!       Get value of bit in mask word corresponding to CHANNEL. STATE indicates
!       if set or cleared(true/fasle).
!******************************************************************************
	use camac_def
	IMPLICIT NONE

	integer :: pmt_number
	logical :: state
	integer :: slot
	integer :: bit
	character(len=4) :: pmtnumber
        CHARACTER(len=80) :: MSG        ! error message 
        INTEGER ::      jERR            ! return code         

        CHARACTER(*), PARAMETER :: SRN = "GPR_GETCFDMASK"


!Check channel is legal.
						  ! enable or disable.
	if(pmt_number>n_cfd_discriminators*n_cfd_chan.or. &
		& pmt_number<=0)then
	     write(pmtnumber,'(i4)')pmt_number
             msg="Specified Cfd channel #"//trim(pmtnumber)// &
	        &" out of range. NO CFDs changed."
	     JERR=GOS_ERROR(SRN,MSG,32) 
	     state=.false.
	     return
	endif

	slot=((pmt_number-1)/16) +1     !Integer round down here.
				       ! slots start at 1.
	bit= pmt_number-16*(slot-1)-1  !bit 0 is first bit of mask.
	
!TEST the bit in the word.
	state=btest(cfd(slot)%mask,bit)
	return
  END SUBROUTINE GPR10_GETCFDMASK
!******************************************************************************

  SUBROUTINE GPR10_SETCFDMASK(pmt_number,state)
!******************************************************************************
!	Set/clear bit in mask word corresponding to CHANNEL. STATE indicates
!       if set or clear.
!******************************************************************************
	use camac_def
	IMPLICIT NONE

	integer :: pmt_number
	logical :: state
	integer :: slot
	integer :: bit
	character(len=4) :: pmtnumber
        CHARACTER(len=80) :: MSG        ! error message 
        INTEGER ::      jERR            ! return code         

        CHARACTER(*), PARAMETER :: SRN = "GPR_SETCFDMASK"


!Check channel is legal.
						  ! enable or disable.
        write(pmtnumber,'(i4)')pmt_number
	if(pmt_number>n_cfd_discriminators*n_cfd_chan.or. &
		& pmt_number<=0)then
             msg="Specified Cfd channel #"//trim(pmtnumber)// &
	        &" out of range. NO CFDs changed."
	     JERR=GOS_ERROR(SRN,MSG,32) 
	     return
	endif

	slot=((pmt_number-1)/16 +1)	    	!slots start at 1.
	bit= pmt_number-16*(slot-1)-1 	!bit 0 is first bit of mask.
	
!set the bit in the word or clear it depending on logical value of state.
	if(state)then	!set bit
		cfd(slot)%mask=ibset(cfd(slot)%mask,bit)
	else
		cfd(slot)%mask=ibclr(cfd(slot)%mask,bit)
	endif
	return
  END SUBROUTINE GPR10_SETCFDMASK
!******************************************************************************


!******************************************************************************

   SUBROUTINE GPR10_SET_CFD_THRESHOLD
!-------------------------------------------------------------------------------
!       Load array that is loaded into a lecroy CFD disc threholds.
!	Then load the thresholds, masks etc into the CFDs
!	Can only be done if we don not have a run in progress.
!       
!-------------------------------------------------------------------------------
!Modified:

!       13/03/02 GHS
!               Add a 'slot' argument to GPR10_SET_DISCS. A value of -1 means
!               update all cfd slots. Otherwise only update/set that slot. Do
!               this to spped up the GPR10_SET_MASK routine


	USE CAMAC_DEF

        IMPLICIT NONE 

        INTEGER ::      CRATE           ! crate number 
        INTEGER ::      SLOT            ! slot number 
	integer ::	channel	        ! Channel to load
	integer ::	threshold	! Threshold value to load.
        CHARACTER(len=80) :: MSG        ! error message 
        INTEGER ::      jERR            ! return code         
	integer :: i,j,k
	character(len=2) :: crate_id,slot_id	
	character(len=3) :: threshold_id	

        CHARACTER(*), PARAMETER :: SRN = "GPR_SET_CFD_THRESHOLD"


	if(gpr10_ctrl%run_status)then	!Run in progeress. if so leave
 msg="Can not set CFD thresholds while run is in progress. NO CFDs changed."
		JERR=GOS_ERROR(SRN,MSG,32) 
		return
	endif

        CALL KUGETI(crate)                        ! get crate number 
        CALL KUGETI(SLOT)                         ! get slot number 
        CALL KUGETI(Channel)                      ! get channel number 
        CALL KUGETI(threshold)                    ! get channel number 


!Check if all discriminators should be loaded
    If(SLOT==-1)then
        do k=1,n_cfd_discriminators
	   	if (cfd(k)%online) then
			do j=0,n_cfd_chan-1
			   cfd(k)%threshold(j)=threshold
			enddo
        	endif
	enddo
    else

!	Check crate and slot number are valid
	do i=1,n_cfd_discriminators
		if(cfd(i)%crate==crate)then
			if(cfd(i)%slot==slot)then
				exit
			endif
		elseif(i==n_cfd_discriminators) then
			write(slot_id,'(i2)')slot
			write(crate_id,'(i2)')crate
			msg="No CFD in Crate:"//crate_id//" and slot"//slot_id
			JERR=GOS_ERROR(SRN,MSG,32) 
			return
		endif
	enddo

!Threshold set within 1 module only.
!Check its online.
	if(.not.cfd(i)%online)then
		write(slot_id,'(i2)')slot
		write(crate_id,'(i2)')crate
		msg="CFD module in Crate:"//crate_id//" and slot"//slot_id//&
			& " is presently OFFLINE"
		JERR=GOS_ERROR(SRN,MSG,32) 
		return
	endif
	!Check to see if were to load the complete module
	if(channel==-1)then
		do j=0,n_cfd_chan-1
			cfd(i)%threshold(j)=threshold
		enddo
	else
		cfd(i)%threshold(channel)=threshold
	endif
    endif
!Load and read the thresholds after loading. Can only be done from here if a
!Run is not in progress. This prevents any non-thread safe Hytec code from
!screwing up.
!crate 6
!CFD's
	do i=1,n_cfd_discriminators
		do j=0,n_cfd_chan-1
			call cdreg(cfd(i)%ext_reg_code(j),branch,cfd(i)%crate, &
		  	& cfd(i)%slot,j)           
		enddo
	enddo

!	Initialise (make a connection to) the ecc manager
        write(*,*)"CFDS ccinit"
	call ccinit(BRANCH)
	write(*,*)"CFDS gpr10_set_discs" 
 	call gpr10_set_discs(-1)
!HJR 	call ccfini(branch)		!Disconnect from ecc manager
	write(*,*)"CFDs ccfini"
 	call ccfini			!Disconnect from ecc manager

	write(threshold_id,'(i3)')threshold
        msg="CFD threshold is "//threshold_id//" mV" 
	JERR=GOS_ERROR(SRN,MSG,0) 

	return
  END SUBROUTINE GPR10_SET_CFD_THRESHOLD
!******************************************************************************

   SUBROUTINE GPR10_SHOW_CFD_THRESHOLD
!-------------------------------------------------------------------------------
!       Print out to thew history window the current values of the threholds.
!These are the values as read as of the last time CFD's were set.
!-------------------------------------------------------------------------------
	USE CAMAC_DEF

        IMPLICIT NONE 

        CHARACTER(len=80) :: MSG        ! error message 
         INTEGER ::      jERR       ! return code         
	integer :: i,j,k
	character(len=2) :: crate_id,slot_id	

        CHARACTER(*), PARAMETER :: SRN = "GPR10_SHOW_CFD_THRESHOLD"


msg="CFD thresholds as read as of last time Discriminators were set:"
	JERR=GOS_ERROR(SRN,MSG,32) 
msg=  &
&"Crate Slot CH:0  1  2  3  4  5  6  8  9 10 11 12 13 14 15"
	JERR=GOS_ERROR(SRN,MSG,32) 
msg=  &
&"--------------------------------------------------------------------------"
	JERR=GOS_ERROR(SRN,MSG,32) 
	do i=1,n_cfd_discriminators
		if(cfd(i)%online)then
			write(msg,'(i4,i5,5x,16(i4))') cfd(i)%crate, &
			 &  cfd(i)%slot,(cfd(i)%act_threshold(j),j=0,15)
			JERR=GOS_ERROR(SRN,MSG,32) 
		else
			write(msg,'(i4,i5,"---OFFLINE----")') cfd(i)%crate, &
			 &  cfd(i)%slot
		endif
	enddo
	return
   END SUBROUTINE GPR10_SHOW_CFD_THRESHOLD
!******************************************************************************

!   SUBROUTINE GPR10_SYNCH
!!----------------------------------------------------------------------
!!      Synchronises the VAX clock with the GPS UTC time
!!      if they already agree to within MARGIN seconds
!!----------------------------------------------------------------------
!!      call this after Camac initialisation but before producer thread starts!
!
!!      SMB, under construction! Bits taken from GPR10_camac_fna
!!      GPR10_init and SUBROUTINE GRC$SYNCH in 
!!      USR1:[ACQUISITION.GRC.V030] grc.for
!
!       USE CAMAC_DEF
!
!       IMPLICIT NONE
!
!        real :: margin,utc_diff
!        REAL*8 :: UTC_NOW,camac_utc,utc_offset,local_time
!	character(len=9) :: grs2_date,system_date
!	character(len=11) :: grs2_time,system_time
!        INTEGER ::   ierr,jerr
! 	integer,dimension(8):: ival(8)
!	CHARACTER(len=80) :: MSG
!        CHARACTER(*), PARAMETER :: SRN="GPR10_SYNCH"
!	character(len=10) :: c_utc_diff,c_margin
!
!
!	if(gpr10_ctrl%run_status)then	!Run in progeress. if so leave
! msg="Cannot SYNC Computer and GPS time while run is in progress."
!		JERR=GOS_ERROR(SRN,MSG,32) 
!		return
!	endif
!	if(.not.grs2%online)then
! msg="GRS2 is OFFLINE! Can not read (or SYNCH) GPS time!"
!		JERR=GOS_ERROR(SRN,MSG,32) 
!		return
!	endif
!
!
!        CALL KUGETR(margin)                         ! get margin value.
!
!!Get GRS2 time.
!	call gpr10_get_GRS2_time(camac_utc)
!!Get computer MJD time
!	CALL GOS_UTC(UTC_NOW,jerr)
!
!!Print out times
!	call date_and_time(values=ival)
!        UTC_OFFSET  =  IVAL(4) / 1440D0                ! local-UTC time [mjd]
!
!	local_time=camac_utc+utc_offset
!	call gon_utc_date(local_time,grs2_date,grs2_time,ierr)
!	msg="Local GPS time from TRU-TIME clock:"//grs2_date//" "//grs2_time
!       	jerr=gos_ERROR(SRN,MSG,5) 
!
!	local_time=utc_now+utc_offset
!	call gon_utc_date(local_time,system_date,system_time,ierr)
!	msg="Local Computer time:"//system_date//" "//system_time
!       	jerr=gos_ERROR(SRN,MSG,5) 
!		
!!See if we are to  test whether to sych now or not.
!	if(margin>0)then
!					  !get the computer time UTC [mjd]
!		utc_diff=abs(utc_now-camac_utc)*seconds_in_day
!		if(utc_diff<1000000.0)then
!			write(c_utc_diff,'(f10.1)')utc_diff
!		msg="Before SYNC time difference is:"//c_utc_diff//" seconds."
!		else
!    msg="Time difference > 1000000 seconds. Thats way too big. Its huge!"
!		endif
!	       	jerr=gos_ERROR(SRN,MSG,5) 
!		if(utc_diff>margin) then
!			write(c_margin,'(f6.1)')margin
!msg="This is bigger then allowable MARGIN of:"//c_margin//" seconds"
!	       		jerr=gos_ERROR(SRN,MSG,5) 
!msg="No SYNC between Computer and GPS clocks has been attempted."
!		       	jerr=gos_ERROR(SRN,MSG,5) 
!msg="To force a SYNCH use the:   SYNCH -1   command."
!		       	jerr=gos_ERROR(SRN,MSG,5) 
!			return
!		endif
!	endif
!
!!synch them whenever margin = -1 or margin < utc_diff
!	local_time=camac_utc+utc_offset
!
!	call gpr10_set_system_time(local_time,ierr)
!
!!Print out new difference.
!!Get GRS2 time.
!	call gpr10_get_GRS2_time(camac_utc)
!!Get computer MJD time
!	CALL GOS_UTC(UTC_NOW,jerr)
!	utc_diff=abs(utc_now-camac_utc)*seconds_in_day
!	write(c_utc_diff,'(f6.1)')utc_diff
!msg="After SYNC of Computer time to GPS,difference is:"//c_utc_diff//&
!	&"seconds."
!       	jerr=gos_ERROR(SRN,MSG,5) 
!	return
!   END SUBROUTINE GPR10_SYNCH
!!******************************************************************************!


   SUBROUTINE GPR10_SYNCH
!----------------------------------------------------------------------
!      Synchronises the VAX clock with the GPS MJD time
!      if they already agree to within MARGIN seconds
!----------------------------------------------------------------------
!      call this after Camac initialisation but before producer thread starts!

!      SMB, under construction! Bits taken from GPR10_camac_fna
!      GPR10_init and SUBROUTINE GRC$SYNCH in 
!      USR1:[ACQUISITION.GRC.V030] grc.for

!	modified:

!	23/04/01  GHS
!		Add the use of Hytec_gps clock to this routine. Reorder logic.
!		Incorporate old routine GPR10_GET_GPS2_TIME into
!		GPR10_GET_GPS_TIMES.	


       USE CAMAC_DEF

       IMPLICIT NONE

        real :: margin,mjd_diff
        REAL*8 :: MJD_NOW,mjd_new,grs2_mjd,hytec_gps_mjd,mjd_offset,local_time
	character(len=9) :: gps_date
	character(len=11) :: gps_time
        INTEGER ::   ierr,jerr
 	integer,dimension(8):: ival(8)
	CHARACTER(len=80) :: MSG
        CHARACTER(*), PARAMETER :: SRN="GPR10_SYNCH"
	character(len=10) :: c_mjd_diff,c_margin
         CHARACTER(len=32) :: CMD        ! command invoked
        INTEGER  ::          NPAR       ! number of command parameters
         CHARACTER(len=32) :: clock        ! clock specification
	integer :: clen
 
!Run in progress? if so leave
	if(gpr10_ctrl%run_status)then 
	msg="Cannot SYNC Computer and GPS time while run is in progress."
		JERR=GOS_ERROR(SRN,MSG,32) 
	msg="No SYNCH performed!"
    		jerr=gos_ERROR(SRN,MSG,5) 
		return
	endif
 

! Check that at least one of the gps clocks is on line.
	if((.not.grs2%online).and.(.not.hytec_gps%online))then
	msg="Both GPS clocks are OFFLINE! Can not read (or SYNCH) GPS time!"
		JERR=GOS_ERROR(SRN,MSG,32) 
	msg="No SYNCH performed!"
    		jerr=gos_ERROR(SRN,MSG,5) 
		return
	endif


!**********************************************************************
!Get all times:
!**********************************************************************
!Get GRS2 and hytec-gps mjd times(if online).
	call gpr10_get_gps_times(grs2_mjd,hytec_gps_mjd)
!Get computer MJD time
	CALL GOS_utc(mjd_NOW,jerr)
!**********************************************************************


!**********************************************************************
!Print out times
!**********************************************************************
	call date_and_time(values=ival)
        MJD_OFFSET  =  IVAL(4) / 1440D0                ! local-MJD time [mjd]

   !GRS2:
	if(grs2%online)then
	    local_time=grs2_mjd+mjd_offset
	    call gon_utc_date(local_time,gps_date,gps_time,ierr)
	msg="Local GPS time from TRU-TIME clock:"//gps_date//" "//gps_time
       	    jerr=gos_ERROR(SRN,MSG,5) 
        endif

   !HYTEC_GPS:
	if(hytec_gps%online)then
	    local_time=hytec_gps_mjd+mjd_offset
	    call gon_utc_date(local_time,gps_date,gps_time,ierr)
	msg="Local GPS time from HYTEC GPS clock:"//gps_date//" "//gps_time
       	    jerr=gos_ERROR(SRN,MSG,5) 
        endif

   !COMPUTER:
	local_time=mjd_now+mjd_offset
	call gon_utc_date(local_time,gps_date,gps_time,ierr)
	msg="Local Computer (System) time:       "//gps_date//" "//gps_time
       	jerr=gos_ERROR(SRN,MSG,5) 
!**********************************************************************

!See if we are to force a synch with a particular clock.
	CALL KUPATL(CMD,NPAR)
	CALL CLTOU(cmd)                      ! convert to upper case 
	CALL KUGETR(MARGIN)
	if(npar>1)then
	    CALL KUGETC(clock,CLEN)                ! get clock type
	    CALL CLTOU(clock)                      ! convert to upper case
	else
	    clock="NONE"              		!Default clock type.
	endif

	if(index(clock,"NONE")==0)then
!****************************************************************************
!         Tru-Time
!****************************************************************************
		if(index(clock,"TRU")/=0)then
		   if(.not.grs2%online)then
	msg="Tru-Time clock requested for synch but it is off line."
       	     		jerr=gos_ERROR(SRN,MSG,5) 
	msg="No SYNCH performed!"
       	     		jerr=gos_ERROR(SRN,MSG,5) 
	       		return
		   else
	  		mjd_new=grs2_mjd
	msg="Attempting to SYNCH computer clock to TRU-Time GPS clock."
     		     	jerr=gos_ERROR(SRN,MSG,5)
   		   endif
!****************************************************************************
!	Hytec-GPS
!****************************************************************************
		elseif(index(clock,"HYTEC")/=0)then
		   if(.not.hytec_gps%online)then
				  	   	
	msg="HYTEC-GPS clock requested for sych but it is off line."
       	     		jerr=gos_ERROR(SRN,MSG,5) 
	msg="No SYNCH performed!"
       	     		jerr=gos_ERROR(SRN,MSG,5) 
		       	return
		   else
  		      	mjd_new=hytec_gps_mjd
	msg="Attempting to SYNCH computer clock to Hytec GPS clock."
     	     	   	jerr=gos_ERROR(SRN,MSG,5)
                   endif
!****************************************************************************
! Illegal clock specification.
!****************************************************************************
            elseif(index(clock,"NONE")==0)then
	msg="GPS clock specification error. Should be Tru-Time or Hytec."
     	    	   jerr=gos_ERROR(SRN,MSG,5)
	msg="No SYNCH performed!"
    		   jerr=gos_ERROR(SRN,MSG,5) 
		   return
	    endif
!****************************************************************************
! NONE specified: Try both clocks.
!****************************************************************************
	elseif(grs2%online.and.hytec_gps%online)then
		mjd_diff=abs(hytec_gps_mjd-grs2_mjd)*seconds_in_day
			!Allow 1 sec difference between clocks before we decide
			!one of them(or both)have problems.
		if(mjd_diff<1.0)then
		   mjd_new=hytec_gps_mjd
	msg="Tru-Time and Hytec GPS clocks agree"
     	     	   jerr=gos_ERROR(SRN,MSG,5)
	msg="Attempting to SYNCH computer clock to Hytec GPS clock."
     	     	   jerr=gos_ERROR(SRN,MSG,5)
 		else
		   if(mjd_diff<1000000.0)then
			write(c_mjd_diff,'(f10.1)')mjd_diff
		   else
			c_mjd_diff=" > 1000000"
		   endif
	msg="Tru-Time and Hytec clocks disagree by "//c_mjd_diff//" seconds."
     	     	   jerr=gos_ERROR(SRN,MSG,5)
	msg="GPS clock FAILURE! No SYNCH performed!"
    	           jerr=gos_ERROR(SRN,MSG,5) 
	msg="Use commands: SYNCH -1 TRU-TIME   or: SYNCH -1 HYTEC"
     	     	   jerr=gos_ERROR(SRN,MSG,5)
		   return
		endif
        elseif(grs2%online)then
	msg="Attempting to SYNCH computer clock to Tru-Time GPS clock."
     	     	jerr=gos_ERROR(SRN,MSG,5)
		mjd_new=grs2_mjd
	elseif(hytec_gps%online)then
 	msg="Attempting to SYNCH computer clock to Hytec GPS clock."
       		jerr=gos_ERROR(SRN,MSG,5)
   		mjd_new=hytec_gps_mjd
	endif

!See if we are to sych now or not.
	if(margin>0)then
		mjd_diff=abs(mjd_now-mjd_new)*seconds_in_day
		if(mjd_diff<1000.0)then
			write(c_mjd_diff,'(f10.1)')mjd_diff
        msg="Before SYNC time difference is:"//c_mjd_diff//" seconds."
		else
    msg="Time difference > 1000 seconds. Thats way too big. Its huge!"
		endif
	       	jerr=gos_ERROR(SRN,MSG,5) 
		if(mjd_diff>margin) then
			write(c_margin,'(f6.1)')margin
msg="This is bigger then allowable MARGIN of:"//c_margin//" seconds"
	       		jerr=gos_ERROR(SRN,MSG,5) 
msg="No SYNC between Computer and GPS clocks have been attempted."
		       	jerr=gos_ERROR(SRN,MSG,5) 
msg="To force a SYNCH use the:   SYNCH -1   command."
		       	jerr=gos_ERROR(SRN,MSG,5) 
			return
		endif
	endif

!synch them whenever margin = -1 or margin < mjd_diff
	local_time=mjd_new+mjd_offset

	call gpr10_set_system_time(local_time,ierr)
					
!**************************************************************************
!Print out new time
!**************************************************************************
	!Get computer MJD time
	CALL GOS_UTC(MJD_NOW,jerr)
	local_time=mjd_now+mjd_offset
	call gon_utc_date(local_time,gps_date,gps_time,ierr)
	msg="Local Computer (System) time is now:"//gps_date//" "//gps_time
       	jerr=gos_ERROR(SRN,MSG,5) 
	return
 !**************************************************************************
    END SUBROUTINE GPR10_SYNCH

    SUBROUTINE GPR10_GET_GPS_TIMES(grs2_mjd,hytec_gps_mjd)
!-----------------------------------------------------------------------
!Get GPS TRU-TIME clock time from GRS2 interface.
!Get HYTEC GPS clock time from HYTEC-GPS time stamp camac module.
!-----------------------------------------------------------------------
       USE CAMAC_DEF

       IMPLICIT NONE
       INTEGER*4,target :: data4(0:2)
       integer*4, dimension(:), pointer :: dataptr
	INTEGER*2,target :: data2(4)
	integer*2, pointer,dimension(:) :: gpsptr


       REAL*8 :: grs2_mjd,hytec_gps_mjd
       REAL*8 :: grs2mjd       		!External routine declaration
       INTEGER ::   i,jerr,error
       CHARACTER(len=80) :: MSG
       CHARACTER(*), PARAMETER :: SRN="GPR10_GET_GPS_TIMES"

       type(gdf_ev10_t),pointer :: hytec_event  !Points to normal GDF 
					   !structure. 
					   !We use for compatability with
					   !the GPR10_DECODE_HYTEC_GPS ROUTINE.

!*****************************************************************************
!	Set up to active the strobe line(to IRQ on GRS2, and event on 
!       hytec-gps) from the sob.  Connect to ECC.
!*****************************************************************************
		call cdreg(sob4%ext_reg_code(a3),branch,sob4%crate,sob4%slot,a3)
			!Initialise (make a connection to) the ecc manager
		call ccinit(BRANCH) 
!*****************************************************************************


!*****************************************************************************
!Set up stuff for doing the camac operations on the Hytec GPS clock
!*****************************************************************************
	if(hytec_gps%online)then
            call cdreg(hytec_gps%ext_reg_code(a0),branch,hytec_gps%crate,  &
	        & hytec_gps%slot,a0)
            call cdreg(hytec_gps%ext_reg_code(a1),branch,hytec_gps%crate,  &
	        & hytec_gps%slot,a1)
            call cdreg(hytec_gps%ext_reg_code(a2),branch,hytec_gps%crate,  &
	        & hytec_gps%slot,a2)
            call cdreg(hytec_gps%ext_reg_code(a3),branch,hytec_gps%crate,  &
	        & hytec_gps%slot,a3)
					!Setup Hytec GPS for event trigger.
!Clear Hytec GPS LAM
	    status=fcssa(f10,hytec_gps%ext_reg_code(a0),w_data_i2,q)
	    if(.not.btest(status,0)) then
		call gos_signal(srn,status)
	        MSG  = "Failed to clear Hytec GPS LAM"
        	jerr=gos_ERROR(SRN,MSG,5) 
		call ccfini
		return           
	    ENDIF
!Enable Hytec GPS LAM
	    status=fcssa(f26,hytec_gps%ext_reg_code(a0),w_data_i2,q)
	    if(.not.btest(status,0))then
		call gos_signal(srn,status)
	        MSG  = "Failed to clear Hytec GPS LAM"
         	jerr=gos_ERROR(SRN,MSG,5) 
		call ccfini
		return
	    ENDIF
	endif
!*****************************************************************************

!*****************************************************************************
!	Setup to trigger and read Tru-Time GRS2 interface.
!*****************************************************************************
	if(grs2%online)then
		!read the time from the CAMAC gps interface in crate 4
		!Note that this is a 24 bit read!!!!
		!make cdreg codes needed for the ECC using parameters defined
		!in gpr10.f90:
 		call cdreg(grs2%ext_reg_code(a0),branch,grs2%crate,grs2%slot,&
			 & a0)
 		call cdreg(grs2%ext_reg_code(a1),branch,grs2%crate,grs2%slot,&
			 & a1)
       		call cdreg(grs2%ext_reg_code(a2),branch,grs2%crate,grs2%slot,&
			 & a2)

!First: Clear GRS2
	       	status=fcfsa(f2,grs2%ext_reg_code(a2),data4(2),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
		        MSG  = "Failed to clear GPS interface"
         		jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
			return
		endif                    
	endif
!*****************************************************************************

!*****************************************************************************
!Now strobe IRQ line to get GPS times. This is done through sob4-a3-out.
!*****************************************************************************
	status=fcssa(f25,sob4%ext_reg_code(a3),w_data_i2,q)
	if(.not.btest(status,0)) then
		call gos_signal(srn,status)
		MSG  = "Failed to generate SOB GPS Clocks triggers."
         	jerr=gos_ERROR(SRN,MSG,5) 
		call ccfini
		return
	endif                    

!*****************************************************************************

!*****************************************************************************
! Hytec GPS read in and convert to MJD
!*****************************************************************************
	if(hytec_gps%online)then
!Read in the 16 bit registers.
	       	status=fcssa(f0,hytec_gps%ext_reg_code(a0),data2(1),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read Hytec GPS"
	         	jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
		 	return
		endif
       		status=fcssa(f0,hytec_gps%ext_reg_code(a1),data2(2),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read Hytec GPS"
	         	jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
		 	return
		endif
       		status=fcssa(f0,hytec_gps%ext_reg_code(a2),data2(3),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read Hytec GPS"
	         	jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
		 	return
		endif
       		status=fcssa(f0,hytec_gps%ext_reg_code(a3),data2(4),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read Hytec GPS"
	         	jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
		 	return
		endif

!Clear LAM
		status=fcssa(f10,hytec_gps%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
		        MSG  = "Failed to clear Hytec GPS LAM"
         		jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
			return           
		ENDIF
!Enable LAM
		status=fcssa(f26,hytec_gps%ext_reg_code(a0),w_data_i2,q)
		if(.not.btest(status,0))then
			call gos_signal(srn,status)
		        MSG  = "Failed to clear Hytec GPS LAM"
         		jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
			return
		ENDIF

		gpsptr=>data2 !Point to the Hytec gps clock data
				!Convert raw time to mjd,sec,ns and place into
				!event record
		allocate(hytec_event,stat=error)
		if(error/= 0)then
	msg="Program could not alloctae space for SYNCH Hytec event buffer."
			JERR=GOS_ERROR(SRN,MSG,error) 
                        hytec_gps_mjd=0.
		else
			call gpr10_decode_hytec_gps(gpsptr,hytec_event)	
		        hytec_gps_mjd=hytec_event%gps_mjd+ &
			& (hytec_event%gps_sec + hytec_event%gps_ns/1.e9)/&
			& seconds_in_day
		endif
		deallocate(hytec_event)
	else
		hytec_gps_mjd=0.
	endif
!*****************************************************************************

!*************************************************************************
! GRS2 tru-time GPS read in and convert to MJD
!*****************************************************************************
	if(grs2%online)then
!Read in the GRS2 registers.
	       	status=fcfsa(f2,grs2%ext_reg_code(a0),data4(0),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read GRS2 GPS interface"
	         	jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
		 	return
		endif
       		status=fcfsa(f2,grs2%ext_reg_code(a1),data4(1),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read GPS interface"
	         	jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
		 	return
		endif
       		status=fcfsa(f2,grs2%ext_reg_code(a2),data4(2),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read GPS interface"
	         	jerr=gos_ERROR(SRN,MSG,5) 
			call ccfini
		 	return
		endif
!convert to MJD
		dataptr => data4
	       	grs2_mjd = grs2mjd(dataptr)        !Rod Lessard's C routine
	else
		grs2_mjd=0
	endif
!******************************************************************************

	call ccfini
	return
    END SUBROUTINE GPR10_GET_GPS_TIMES
!******************************************************************************



    SUBROUTINE GPR10_GET_GRS2_TIME(camac_utc)
!-----------------------------------------------------------------------
!Get GPS TRU-TIME clock time form GRS2 interface.
!-----------------------------------------------------------------------
       USE CAMAC_DEF

       IMPLICIT NONE
       INTEGER*4,target :: data(0:2)
       integer*4, dimension(:), pointer :: dataptr
       REAL*8 :: camac_utc
       REAL*8 :: grs2mjd
       INTEGER ::   i,jerr
       CHARACTER(len=80) :: MSG
       CHARACTER(*), PARAMETER :: SRN="GPR10_GET_ALL_TIMES"

	if(grs2%online)then
!      read the time from the CAMAC gps interface in crate 4
!Note that this is a 24 bit read!!!!
! first make cdreg codes needed for the ECC using parameters defined in 
!gpr10.f90:
!GRS2 first
 		call cdreg(grs2%ext_reg_code(a0),branch,grs2%crate,grs2%slot,&
			 & a0)
 		call cdreg(grs2%ext_reg_code(a1),branch,grs2%crate,grs2%slot,&
			 & a1)
       		call cdreg(grs2%ext_reg_code(a2),branch,grs2%crate,grs2%slot,&
			 & a2)
!And the strobe line(to IRQ on GRS2) from the sob
		call cdreg(sob4%ext_reg_code(a3),branch,sob4%crate,sob4%slot,a3)

!	Initialise (make a connection to) the ecc manager
		call ccinit(BRANCH) 

!First: Clear GRS2
	       	status=fcfsa(f2,grs2%ext_reg_code(a2),data(2),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
		        MSG  = "Failed to clear GPS interface"
         		jerr=gos_ERROR(SRN,MSG,5) 
!HJR 			call ccfini(branch)
			call ccfini
			return
		endif

!Now strobe IRQ line to get GPS time. This is done through sob4-a3-out.
		status=fcssa(f25,sob4%ext_reg_code(a3),w_data_i2,q)
		if(.not.btest(status,0)) call gos_signal(srn,status)


!Read in the GRS2 registers.
	       	status=fcfsa(f2,grs2%ext_reg_code(a0),data(0),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read GPS interface"
	         	jerr=gos_ERROR(SRN,MSG,5) 
!HJR 			call ccfini(branch)
			call ccfini
		 	return
		endif
       		status=fcfsa(f2,grs2%ext_reg_code(a1),data(1),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read GPS interface"
	         	jerr=gos_ERROR(SRN,MSG,5) 
!HJR 			call ccfini(branch)
			call ccfini
		 	return
		endif
       		status=fcfsa(f2,grs2%ext_reg_code(a2),data(2),q)
		if(.not.btest(status,0)) then
			call gos_signal(srn,status)
	         	MSG  = "Failed to read GPS interface"
	         	jerr=gos_ERROR(SRN,MSG,5) 
!HJR 			call ccfini(branch)
			call ccfini
		 	return
		endif

!convert to MJD
		dataptr => data
	       	camac_utc = grs2mjd(dataptr)        !Rod Lessard's C routine
	else
		camac_utc=0
	endif
!HJR 	call ccfini(branch)
	call ccfini
	return
    END SUBROUTINE GPR10_GET_grs2_TIME
!******************************************************************************

    SUBROUTINE GPR10_READ_I2_BUFFER(list_proc,ptr,length,start,ierr)
!	Read a block of data from the list processor. Repeat read attempt
!       if it doesn't work.
	use camac_def

        IMPLICIT NONE 

	type(camac_module) :: list_proc

	logical,intent(out):: ierr
	integer*4,dimension(4) :: cb
	integer :: resub
	integer*2,dimension(:),pointer :: ptr
	character(len=2) :: crate_id
	integer :: jerr
	character(*),PARAMETER :: SRN="GPR10_READ_I2_BUFFER"
	character(len=80) :: msg
        integer*4 :: length,start
	character(len=10) :: c_cb,c_length

	ierr=.false.
	if(length>0)then
	 	cb(1)=length		!set up word count array.
		cb(2)=0	
		cb(3)=0
		cb(4)=0

!now read in lp memory, syncronously using the write memory address pointer.
! It may be faster to do this
!Note that this is a 16 bit read.
							 !All data is contained
							  !in 16 bit data words
		status=fcsubc(f0,list_proc%ext_reg_code(a1),%ref(ptr),cb)
!		status=fcsubr(f0,list_proc%ext_reg_code(a1),%ref(ptr),cb)
		if(.not.btest(status,0)) call gos_signal(srn,status)
!Hardware Check: Check that the lp read worked.			
		resub=0
       		do
		   if(cb(2).ne.length)then
			call gos_signal(srn,status)
	   		resub=resub+1
			write(crate_id,'(i2)')list_proc%crate
			msg="Read of data from LP in Crate #"//&
		    	&crate_id//" using FCSUBC command Failed."
	       		JERR=GOS_ERROR(SRN,MSG,31) 

			write(c_length,'(i10)')length
			write(c_cb,'(i10)')cb(2)
			msg="Requested:"//c_length//" got:"//c_cb
	       		JERR=GOS_ERROR(SRN,MSG,31) 
			if(resub.gt.3)then
				msg="It don't work. I quit! Aborting Run!"
				JERR=GOS_ERROR(SRN,MSG,31) 
			        ierr=.true.
				gpr10_ctrl%quit=.true.
				return
			else
				msg="Attempting to recover by resubmission of&
				    &  FCSUBC"
				JERR=GOS_ERROR(SRN,MSG,31) 

!Reload write memory address pointer since our failed read may have changed it.
				status=fcfsa(f17,list_proc%ext_reg_code(a1),&
				       &start,q)
				if(.not.btest(status,0)) &
						& call gos_signal(srn,status)
!Reread the data
			 	cb(1)=length	      !set up word count array.
				cb(2)=0	
				cb(3)=0
				cb(4)=0
!				status=fcsubr(f0,list_proc%ext_reg_code(a1),&
!				       & %ref(ptr),cb)
				status=fcsubc(f0,list_proc%ext_reg_code(a1),&
				       & %ref(ptr),cb)
				if(.not.btest(status,0)) &
						&call gos_signal(srn,status)  

			endif

		   else
			exit		!It worked! Leave!
	    	   endif
		enddo
	endif
	return
   END SUBROUTINE GPR10_READ_I2_BUFFER

!******************************************************************************
   SUBROUTINE GPR10_SET_PST

!-------------------------------------------------------------------------------
!       Set various things in the PST modules.
!	Commands implimented:
!		SET/PST/STATE 
!		SET/PST/MULTIPLICITY
!		SET/PST/LOAD
!		SET/PST/VERIFY
!-------------------------------------------------------------------------------
	USE CAMAC_DEF

        IMPLICIT NONE 

        INTEGER ::     CRATE      ! crate number 
        INTEGER ::     SLOT       ! slot number 

        CHARACTER(len=80) :: MSG        ! error message 
        INTEGER ::      jERR       ! return code         
        CHARACTER(*), PARAMETER :: SRN = "GPR10_SET_PST" 


	integer :: i,j,imult,is,ie
        CHARACTER(len=32) :: CMD        ! command invoked 
        INTEGER  ::     NPAR       ! number of command parameters 

        CHARACTER(len=3) :: STATE      ! new module state ON/OFF

        CHARACTER(len=80) :: pattern !PST valid pixel pattern file

!Stuff for SET/PST/STAT command:
	type(pst_module),pointer :: ptr
!old...	integer,dimension(5) :: pst_mult=(/0,1,3,7,15/) 
!this definition is correct according to the PST data sheet, but in practice
!it was found that one had to write one less bit to set the comparator 
!reference voltage than was stated i.e. actually 1 bit written = 3-fold 
!coincidence (SMB 22/9/98)  so:
        integer,dimension(5) :: pst_mult=(/0,0,1,3,7/) 
        
!to test release 4 of PST module - Dec. 2001 - vref setting is now 
!complementary binary and cannot be read back
        integer,dimension(6) :: pst_v4_mult=(/31,15,7,3,1,0/)   


!Stuff for SET/PST/LOAD and SET/PST/VERIFY commands:
		 !Pointers to dynamically allocate pattern specification array
	integer*2,dimension(:),pointer :: pattern_ptr,pattern_vfy
	integer :: length_19=2**19    		!Length of pattern buffers
        integer :: error,io_err,len
	logical :: pst_verify,pst_exist
        CHARACTER(len=2) :: pst_id


!Read in some common parameters

        CALL KUPATL(CMD,NPAR)    ! get command, number of parameters 
	CALL CLTOU(CMD)                      ! convert to upper case 
        CALL KUGETI(crate)                         ! get crate number 
        CALL KUGETI(SLOT)                         ! get slot number 


	if(gpr10_ctrl%run_status)then	!Run in progress. if so leave
        msg="Cannot access PST while run is in progress."
		JERR=GOS_ERROR(SRN,MSG,1) 
		return
	endif
!-------------------------------------------------------------------------------
!       deal with pattern selection trigger  
!-------------------------------------------------------------------------------
        IF (CMD=="STATE") THEN 


!----     change module state

          ptr=>pst(slot)
	  call gpr10_change_state_pst(ptr,crate,slot)
						!This will also check the crate
						!for us
          return

!MULTIPLICITY:
        ELSEIF (CMD=="MULTIPLICITY") THEN  
!----     user's choice to trigger on patterns of imult = 2,3,4 or 5 pixels
             call KUGETI(imult)

!----     Initialise (connect to) the ecc manager
             call ccinit(BRANCH)

!----     convert the trigger multiplicity, imult, to a bit pattern
             w_data_i2 = pst_mult(imult)
!----     this bit pattern is written to the PST to set the reference 
!----     voltage of the comparator chip


!----       if chosen value of slot is 0 then cycle through ALL modules  
!----   if chosen value of slot is 0 then cycle through ALL modules  
            if (slot<1) then             
		is=1
		ie=npst
	    else
		is=slot
		ie=slot
	    endif

	    pst_exist=.false.
       	    do i=is,ie
		 if(pst(i)%online)then
			 pst_exist=.true.
	      	         call cdreg(pst(i)%ext_reg_code(a0),branch, &
				& pst(i)%crate,pst(i)%slot,a0)
		         status=fcssa(f17,pst(i)%ext_reg_code(a0),w_data_i2,q)
		         if(.not.btest(status,0)) call gos_signal(srn,status)
                	 status=fcssa(f1,pst(i)%ext_reg_code(a0),r_data_i2,q)
		         if(.not.btest(status,0)) call gos_signal(srn,status)
		 	!Find what multiplicity this bit pattern corresponds to.
		         do j=1,5
				if(r_data_i2==pst_mult(j))then
					pst(i)%mult=j
					exit
				endif
			 enddo
		  endif
            enddo
	    if(.not.pst_exist)then
		msg="Requested PST(s) is OFFLINE. Multiplicity not set."
		JERR=GOS_ERROR(SRN,MSG,1) 
	    endif
!HJR 	    call ccfini(branch)		!Disconnect from camac
	    call ccfini			!Disconnect from camac
            return

!test of release 4 PST module - December 2001

         
ELSEIF (CMD=="NEWMULT") THEN  
!----     user's choice to trigger on patterns of imult = 2,3,4 or 5 pixels
             call KUGETI(imult)

!----     Initialise (connect to) the ecc manager
             call ccinit(BRANCH)

!----     convert the trigger multiplicity, imult, to a bit pattern
             w_data_i2 = pst_v4_mult(imult)
!----     this bit pattern is written to the PST to set the reference 
!----     voltage of the comparator chip
         
		is=slot
		ie=slot
	 

	    pst_exist=.false.
       	    do i=is,ie
		 if(pst(i)%online)then
			 pst_exist=.true.
	      	         call cdreg(pst(i)%ext_reg_code(a0),branch, &
				& pst(i)%crate,pst(i)%slot,a0)
		         status=fcssa(f17,pst(i)%ext_reg_code(a0),w_data_i2,q)
		         if(.not.btest(status,0)) call gos_signal(srn,status)

		  endif
            enddo
	    if(.not.pst_exist)then
		msg="Requested PST(s) is OFFLINE. Multiplicity not set."
		JERR=GOS_ERROR(SRN,MSG,1) 
	    endif
!HJR 	    call ccfini(branch)		!Disconnect from camac
	    call ccfini			!Disconnect from camac
            return



!LOAD:
!VERIFY:
        ELSEIF (CMD=="LOAD" .or. cmd=="VERIFY") THEN  
!----     user's choice of pixel patterns to trigger on, to be read in 
!----     from file e.g. PST_nfold.dat where n = 1,2,3,4 or 5 and default
!----     is PST_2fold.dat to get a PST trigger when any two adjacent
!----     pixels are above discriminator threshold.           
!	LOAD loads the file into the pst(s).        
!	VERIFY reads the pst(s) and compares with file.

            call KUGETC(pattern,len)        ! "pattern" is the character string
                                        ! containing the ****.dat file name

            if (slot>0) then
              	if (.not.pst(slot)%online) then
                 	msg="PST is OFFLINE. No action taken"
                 	JERR=GOS_ERROR(SRN,MSG,1)
                 	return
              	endif
	    else
		pst_exist=.false.
		do i=1,npst
			if(pst(i)%online)then
				pst_exist=.true.
				exit
			endif
		enddo
		if(.not.pst_exist)then
	              msg="All PSTs are OFFLINE. No action taken"
                      JERR=GOS_ERROR(SRN,MSG,1)
                      return
		endif
            endif

!Allocate new buffer
	    allocate(pattern_ptr(length_19),stat=error)
	    if(error/= 0)then
		msg="Program could not allocate space for Pattern file buffer."
		JERR=GOS_ERROR(SRN,MSG,error) 
		msg="Chosen pattern not registered"
		JERR=GOS_ERROR(SRN,MSG,31) 
		return
	    endif

!Open input pattern data file and read into buffer
	    open(12,file=pattern,status="OLD",form="UNFORMATTED",iostat=io_err)
	    if(io_err/=0)then
		msg="Error Opening file://pattern//"
		JERR=GOS_ERROR(SRN,MSG,1) 
		deallocate(pattern_ptr)
		close(12)
		return
	    endif

	    read(12,iostat=io_err)pattern_ptr
	    if(io_err/=0)then
		msg="Error Reading file://pattern//"
		JERR=GOS_ERROR(SRN,MSG,1) 
		deallocate(pattern_ptr)
	 	close(12)
		return
	    endif

	    close(12)


!Allocation of verify array
	    if(cmd=="VERIFY")then
	    	allocate(pattern_vfy(length_19),stat=error)
		    if(error/= 0)then
	msg="Program could not allocate space for Pattern verify buffer."
			JERR=GOS_ERROR(SRN,MSG,error) 
			deallocate(pattern_ptr)
			return
		    endif
	    endif

!NOTE: REMEBER TO DEALLOCATE THIS BUFFER(s) ALWAYS BEFORE RETURNING!!!!!!!

!----   initialise (connect to) the ecc manager
            call ccinit(BRANCH)

!load pattern array into PST
!----   if chosen value of slot is 0 then cycle through ALL modules  
            if (slot<1) then             
		is=1
		ie=npst
	    else
		is=slot
		ie=slot
	    endif

       	    do i=is,ie
              

				!See if LOAD or VERIFY
!Make sure this pst is on-line
	    	if (pst(i)%online) then
		    if(cmd=="LOAD")then
			   		!F16 makes this a LOAD command!
			call gpr10_pst_memory(f16,pattern_ptr,crate,i)
		    else
			pattern_vfy=0	!Init array
			call gpr10_pst_memory(f0,pattern_vfy,crate,i)
					!Compare with what it should have been
			pst_verify=.true.
			do j=1,length_19
				if(pattern_ptr(j)/=pattern_vfy(j))then
			       		pst_verify=.false.
!					print*,'Mismatch:pst,j,in,out',slot,j, &
!						&pattern_ptr(j),pattern_vfy(j)
!                                       CALL GPR10_WAIT(5.)
                                      else 
!                                        print*,'Match:pst,j,in,out',slot,j, &
!						&pattern_ptr(j),pattern_vfy(j)

				endif
			enddo
                        write(pst_id,'(i2)')i
		        if(pst_verify)then

		MSG="PST in slot "//pst_id//" memory comparison successful"
			   	JERR=GOS_ERROR(SRN,MSG,0) 
			else
     MSG="PST in slot "//pst_id//" memory comparison failed. Differences found."
			   	JERR=GOS_ERROR(SRN,MSG,1) 
			endif
		    endif
		endif
	     enddo 

	    if(cmd=="VERIFY")then
	        deallocate(pattern_vfy)
	    endif
	    deallocate(pattern_ptr)
!HJR 	    call ccfini(branch)		 	!Disconnect from camac
	    call ccfini			 	!Disconnect from camac
	    return
	ENDIF
   END SUBROUTINE GPR10_SET_PST             
!******************************************************************************

   SUBROUTINE GPR10_SHOW_PST

!-------------------------------------------------------------------------------
!       show PST module state 
!-------------------------------------------------------------------------------
	USE CAMAC_DEF

        IMPLICIT NONE 

        CHARACTER(len=80) :: MSG        ! error message 
         INTEGER ::      jERR       ! return code         
        CHARACTER(len=32) :: CMD        ! command invoked 
        INTEGER  ::i,NPAR       ! number of command parameters 
    
        CHARACTER(*), PARAMETER :: SRN = "GPR10_SHOW_PST" 

        CALL KUPATL(CMD,NPAR)    ! get command, number of parameters 
	CALL CLTOU(CMD)                      ! convert to upper case 


!-------------------------------------------------------------------------------
!       deal with pattern selection trigger  
!-------------------------------------------------------------------------------
          if (CMD=="MULTIPLICITY") then
		write(msg,'("PST Multiplicity:",4(i2,":",i2," fold, "),&
		 &(i2,":",i2," fold"))'),((pst(i)%slot,pst(i)%mult),i=1,5)
		JERR=GOS_ERROR(SRN,MSG,0) 
		write(msg,'("PST Multiplicity:",4(i2,":",i2," fold, "),&
		 &(i2,":",i2," fold"))'),((pst(i)%slot,pst(i)%mult),i=6,10)
		JERR=GOS_ERROR(SRN,MSG,0) 
		write(msg,'("PST Multiplicity:",2(i2,":",i2," fold, "),&
		 &(i2,":",i2," fold"))'),((pst(i)%slot,pst(i)%mult),i=11,13)
		JERR=GOS_ERROR(SRN,MSG,0) 
                return
         endif

        END SUBROUTINE GPR10_SHOW_PST             
!******************************************************************************

  SUBROUTINE GPR10_PST_MEMORY(f_code,ptr,crate,slot)
!-------------------------------------------------------------------------------
!	LOad or UNload the PST memoryt in specified crate and slot using
!	the array pointed to by ptr
	USE CAMAC_DEF

        IMPLICIT NONE 

        INTEGER :: CRATE   			! crate number 
        INTEGER :: SLOT       			! slot number 
	integer*2,dimension(:),pointer :: ptr,p_ptr
	integer :: length_19=2**19    		!Length of pattern buffers
	integer*4,dimension(4) :: cb            !Transfer control block
        integer :: pst_block,num_so_far
	integer*4 :: f_code			!Transfer camac function code.
        CHARACTER(len=2) :: pst_id

        CHARACTER(len=80) :: MSG        ! error message 
        INTEGER ::      jERR       ! return code         
        CHARACTER(*), PARAMETER :: SRN = "GPR10_PST_MEMORY"

!CCINIT was called by callling routine.
!Define somethings for this crate and slot
	call cdreg(pst(slot)%ext_reg_code(a0),branch,pst(slot)%crate, &
		& pst(slot)%slot,a0)
      	call cdreg(pst(slot)%ext_reg_code(a1),branch,pst(slot)%crate, &
		& pst(slot)%slot,a1)

!----   Set pst memory address pointer to 0.
	w_data_i4=0
	status=fcfsa(f17,pst(slot)%ext_reg_code(a1),w_data_i4,q)
	if(.not.btest(status,0))call gos_signal(srn,status)

!----   Load(or read) the program. We have to do this in blocks.
	num_so_far=0
	pst_block=130000 !Approx max number we can transfer
			 !with one fcsubr.(Note: 2**17=131072)
	do
			!Look for last partial block
	   if(num_so_far+pst_block>length_19)then
	   	pst_block=length_19-num_so_far
	   endif

	   p_ptr=>ptr(num_so_far+1:num_so_far+pst_block)

!----   Load up the cb array to determine how much to transfer(direction comes
!	from the value of f_code:f16 load into pst, f0 read from PST.
	   cb(1)=pst_block
	   cb(2)=0
	   cb(3)=0
	   cb(4)=0
	   status=fcsubr(f_code,pst(slot)%ext_reg_code(a0),%ref(p_ptr),cb)
	   if(.not.btest(status,0)) call gos_signal(srn,status)
	   if(cb(2)/=pst_block)then
       		write(pst_id,'(i2)') slot
	 	msg="LOAD  UNLOAD of PST "//pst_id//" memory failed"
     		JERR=GOS_ERROR(SRN,MSG,31)
           	exit
	   endif
	   num_so_far=num_so_far+pst_block

			!See if done
	   if(num_so_far==length_19)then
		exit
	   endif
	enddo
  END SUBROUTINE GPR10_PST_MEMORY
!***************************************************************************

      SUBROUTINE GPR10_WAIT(TIME,IERR) 
!-------------------------------------------------------------------------------
!     go to sleep for a TIME specified in seconds 
!-------------------------------------------------------------------------------
      IMPLICIT NONE 
!---- 
      REAL                   :: TIME 
      INTEGER, OPTIONAL      :: IERR 
!---- 
      INTEGER                :: STATUS 
      INTEGER                :: PTHREAD_DELAY_NP  
      CHARACTER(80)          :: MSG 
      CHARACTER(*),PARAMETER :: SRN="GPR10_WAIT"
      TYPE :: TIMESPEC
        INTEGER SEC
        INTEGER NS
      END TYPE 
      TYPE(TIMESPEC)         :: INTERVAL 
!---- 
      INTERVAL%SEC = INT(TIME)                          ! calc seconds
      INTERVAL%NS  = MOD(TIME,1.0)*1E9                  ! calc nanoseconds
      STATUS = PTHREAD_DELAY_NP(INTERVAL)               ! now wait 
      IF (STATUS.NE.0) THEN                             ! slept well?
        MSG    = "Invalid time interval."               !   no, ...
        STATUS = GOS_ERROR(SRN,TRIM(MSG),STATUS)        !   complain 
        IF (PRESENT(IERR)) IERR = STATUS                !   set error flag 
      ENDIF                                             ! 

      END SUBROUTINE GPR10_WAIT 

      SUBROUTINE gpr10_SET_SYSTEM_TIME(UTC_TIME,ierr) 
!-------------------------------------------------------------------------------
!     Set the system clock (computer time) to utc_time. 
!     UTC_time is in MJD format.
!-------------------------------------------------------------------------------

      IMPLICIT NONE 
!---- 
      REAL*8   :: UTC_TIME
      INTEGER  :: IERR
!---- 
      INTEGER       :: IDATE(7)  ! year, month, day, hour, minute, second, ns
      INTEGER       :: status
      integer*2     :: jdate(8)
      integer*4     :: sys_time(2)
      integer       :: LIB$CVT_VECTIM
      integer       :: LIB$SIGNAL
      integer       :: sys$setime
      CHARACTER(80) :: MSG 
      CHARACTER(*), PARAMETER :: SRN ="GPR10_SET_SYSTEM_TIME"
	

!-------------------------------------------------------------------------------
!     get access to VMS system routines 
!-------------------------------------------------------------------------------
      CALL GOS_LOCK(GOS_MUTEX_VMS,IERR) 
!-------------------------------------------------------------------------------
!     Convert UTC time date into stsem time format, then set system time  
!-------------------------------------------------------------------------------
      call GON_UTC_IDATE(UTC_time,IDATE,IERR)
      if(ierr/=0)then
	msg='GON_UTC_IDATE failed.'
	STATUS = GOS_ERROR(SRN,MSG,1)           !   complain 
      else 
        jdate(1)= idate(1)			! YEAR
        jdate(2)= idate(2)			! MONTH
        jdate(3)= idate(3)			! DAY
        jdate(4)= idate(4)			! Hour
        jdate(5)= idate(5)			! minute
        jdate(6)= idate(6)			! seconds
        jdate(7)= idate(7)/1E7			! Hundreths of seconds
        jdate(8)= 0				! FILLS OUT LAST WORD.
        ierr=LIB$CVT_VECTIM(jdate,sys_TIME)     ! convert time format 
        ierr=SYS$SETIME(SYS_TIME)		! set system time.
      endif
!-------------------------------------------------------------------------------
!     release lock 
!-------------------------------------------------------------------------------
      CALL GOS_UNLOCK(GOS_MUTEX_VMS,IERR) 

      return
      END SUBROUTINE gpr10_SET_SYSTEM_TIME 
!****************************************************************************

   SUBROUTINE GPR10_OVERRIDE
!-------------------------------------------------------------------------------
!       Set override of too little disk space to .true.
!-------------------------------------------------------------------------------
        IMPLICIT NONE 

        CHARACTER(len=80) :: MSG        ! error message 
         INTEGER ::      jERR       ! return code         
    
        CHARACTER(*), PARAMETER :: SRN = "GPR10_OVERRIDE"

	gpr10_ctrl%override=.true.
	gpr10_ctrl%enough_disk=.true.
	JERR=GOS_ERROR(SRN,"OVERRIDE of minimum disk space limit enabled.",1)
	return
   END SUBROUTINE GPR10_OVERRIDE
!******************************************************************************


!******************************************************************************
END MODULE GPR10
